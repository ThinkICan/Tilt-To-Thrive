<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Tilt to Thrive</title>
    <style>
        /* --- CORE STYLES --- */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #051e11; 
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; 
            user-select: none; 
            -webkit-user-select: none; 
        }
        canvas { display: block; }
        
        /* --- UI LAYER --- */
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            text-align: center; 
            z-index: 10;
        }

        /* --- HUD --- */
        #hud-top { 
            position: absolute; 
            top: max(10px, env(safe-area-inset-top)); 
            left: max(15px, env(safe-area-inset-left)); 
            right: max(15px, env(safe-area-inset-right)); 
            display: flex; 
            justify-content: space-between; 
            pointer-events: none; 
        }
        
        .hud-text { 
            font-size: 18px; 
            font-weight: bold; 
            color: #ecf0f1; 
            text-shadow: 1px 1px 0 #000;
        }
        
        #combo-display { 
            color: #f1c40f; 
            font-size: 22px; 
            text-shadow: 0 0 10px rgba(241, 196, 15, 0.8); 
            transition: transform 0.1s; 
        }
        .pulse { transform: scale(1.5); }

        /* --- CONTROLS --- */
        button { 
            pointer-events: auto; 
            padding: 15px 40px; 
            font-size: 20px; 
            font-family: sans-serif;
            font-weight: 800;
            background: linear-gradient(to bottom, #2ecc71, #27ae60); 
            color: white; 
            border: 2px solid #fff; 
            border-radius: 50px; 
            cursor: pointer; 
            box-shadow: 0 0 15px #27ae60; 
            transition: transform 0.1s; 
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        button:active { transform: scale(0.95); }
        button.red { background: linear-gradient(to bottom, #e74c3c, #c0392b); box-shadow: 0 0 15px #c0392b; }

        /* Slider */
        .slider-container { margin-bottom: 20px; pointer-events: auto; width: 200px; }
        input[type=range] { width: 100%; accent-color: #f1c40f; }
        .diff-label { color: #f1c40f; font-weight: bold; margin-top: 5px; display: block; font-family: sans-serif; }

        /* --- SCREENS --- */
        .screen-box {
            pointer-events: auto; 
            background: rgba(5, 25, 10, 0.95); 
            padding: 30px; 
            border-radius: 20px; 
            border: 2px solid #2ecc71; 
            box-shadow: 0 0 30px rgba(46, 204, 113, 0.3);
            max-width: 80%;
        }

        #start-screen, #game-over, #pause-screen { display: none; }
        
        /* --- SPLASH ART STYLING --- */
        #splash-screen {
            pointer-events: auto; 
            cursor: pointer;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #splash-img {
            width: 100%;
            height: 100%;
            object-fit: contain; 
            z-index: 0;
        }

        .splash-overlay {
            position: absolute;
            bottom: 10%;
            width: 100%;
            text-align: center;
            z-index: 2;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        
        .instruction-text { font-size: 18px; color: #fff; margin: 0; font-family: sans-serif; font-weight: bold; opacity: 0.8; }
        
        #rotate-msg { 
            display: flex; 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: #000; 
            z-index: 9999; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            color: white; 
            font-family: sans-serif;
        }

        #mult-bar-container { position: absolute; top: 40px; left: 15px; width: 100px; height: 6px; background: rgba(0,0,0,0.5); border: 1px solid #555; border-radius: 4px; display: none; }
        #mult-bar-fill { height: 100%; width: 100%; background: linear-gradient(90deg, #f1c40f, #e67e22); border-radius: 3px; transition: width 0.1s linear; }
        
        #copyright { margin-top: 5px; color: rgba(255,255,255,0.5); font-size: 12px; font-family: sans-serif; }
        
        #formation-warning {
            display: none;
            position: absolute;
            top: 30%;
            width: 100%;
            text-align: center;
            font-size: 40px;
            color: #e74c3c;
            font-weight: 900;
            text-shadow: 0 0 20px red;
            pointer-events: none;
            animation: flash 0.5s infinite;
        }
        @keyframes flash { 0% {opacity:0;} 50% {opacity:1;} 100% {opacity:0;} }
    </style>
</head>
<body>

    <div id="rotate-msg">
        <img src="icon.jpg" style="width: 150px; height: 150px; border-radius: 30px; margin-bottom: 20px; box-shadow: 0 0 30px #00c6ff;">
        <div style="font-size: 50px; color:#00c6ff; margin: 20px;">⟳</div>
        <p style="color:white; font-size: 24px; font-weight:bold;">Rotate to Landscape</p>
    </div>

    <div id="hud-top">
        <div style="text-align:left;">
            <div id="score-display" class="hud-text">SCORE: 0</div>
            <div id="combo-display" class="hud-text">1x</div>
            <div id="mult-bar-container"><div id="mult-bar-fill"></div></div>
        </div>
        <div id="lives-display" class="hud-text">❤❤❤</div>
    </div>
    
    <div id="ui-layer">
        <h2 id="countdown-text" style="font-size: 100px; color: #fff; text-shadow: 0 0 20px #f1c40f; display:none;">3</h2>
        <div id="formation-warning">⚠ SWARM DETECTED ⚠</div>

        <div id="splash-screen">
            <img id="splash-img" src="splash.jpg" alt="Tilt to Thrive">
            <div class="splash-overlay">
                <p class="instruction-text" style="color: #bdc3c7;">Tap anywhere to begin</p>
                <div id="copyright">© 2025 Steve Elkins</div>
            </div>
        </div>

        <div id="start-screen" class="screen-box">
            <h2 style="margin:0 0 15px 0; color:#2ecc71; display:block;">MISSION</h2>
            <p class="instruction-text" style="margin-bottom: 20px;">
                Avoid the Red Dots<br>
                Collect Yellow Diamonds<br>
                Grab Golden Powerups
            </p>
            
            <div class="slider-container" style="margin: 0 auto 20px auto;">
                <label for="diff-slider" style="color:white; font-family:sans-serif;">Difficulty</label>
                <input type="range" min="1" max="3" value="2" id="diff-slider">
                <span id="diff-val" class="diff-label">NORMAL</span>
            </div>

            <button id="start-btn">LAUNCH</button>
        </div>

        <div id="pause-screen" class="screen-box">
            <h1 style="color:white; font-family:sans-serif;">PAUSED</h1>
            <button id="resume-btn">RESUME</button>
        </div>
        
        <div id="game-over" class="screen-box">
            <h1 style="color: #e74c3c; font-family:sans-serif;">CRITICAL FAILURE</h1>
            <p id="final-score" style="color:white; font-size: 24px;">Score: 0</p>
            <button class="red" id="retry-btn">RETRY</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    // --- CONFIG ---
    const CONFIG = {
        friction: 0.95,         
        acceleration: 0.006,    
        inputExponent: 1.3,     
        maxVelocity: 11.0,
        maxTiltAngle: 35,
        turnBoost: 1.5,         
        
        baseSpeed: 0.1, 
        spawnRate: 0.05,
        waveDuration: 60000,
        
        hitboxRatio: 0.55,
        enemyHitboxRatio: 0.45, 
        diamondHitbox: 15,
        magnetRadius: 50,       
        magnetForce: 0.5,       
        
        shieldRadius: 24,       
        invincibilityTime: 8000,
        
        blackHoleDuration: 10000,
        blackHoleDelay: 2000,   
        blackHoleForce: 0.6,    
        
        fireDuration: 400,      
        fireTrailLife: 7000,    
        fireRadius: 25,         
        
        ionDelay: 1000,         
        ionSpeed: 12,           
        ionGrowth: 0.4,         // Fast expansion
        ionMaxRadius: 150,      // Big explosion
        
        multiplierResetTime: 15000 
    };

    // --- AUDIO ENGINE ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let starOsc = null; 
    let starGain = null;

    let isMusicPlaying = false;
    let musicStartTime = 0;
    let schedulerTimer;
    const MUSIC_TOTAL_DURATION = 300; 
    const C = 261.63, D = 293.66, E = 329.63, F = 349.23, G = 392.00, A = 440.00, B = 493.88;
    const CHORD_PROGRESSION = [[C, E, G], [G, B, D*2], [A, C*2, E*2], [F, A, C*2]];
    let seqState = { chordIndex: 0, noteIndex: 0, beatCounter: 0 };

    function unlockAudio() {
        if (audioCtx.state === 'suspended') { audioCtx.resume(); }
        const buffer = audioCtx.createBuffer(1, 1, 22050); 
        const source = audioCtx.createBufferSource(); 
        source.buffer = buffer; 
        source.connect(audioCtx.destination); 
        source.start(0); 
    }

    // --- SFX ---
    function playSound(type) {
        if (audioCtx.state === 'suspended') return;
        try {
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'beep') { 
                osc.type = 'square'; osc.frequency.setValueAtTime(440, now); osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.1);
                gain.gain.setValueAtTime(0.1, now); osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'go') { 
                osc.type = 'square'; osc.frequency.setValueAtTime(880, now); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                osc.start(now); osc.stop(now + 0.4);
            } else if (type === 'coin') { 
                osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.linearRampToValueAtTime(1800, now + 0.1);
                gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'crash') { 
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.5);
                gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5); osc.start(now); osc.stop(now + 0.5);
            } else if (type === 'powerup') { 
                osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); osc.frequency.linearRampToValueAtTime(800, now + 0.3);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'powerdown') { 
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(100, now + 0.5);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5);
            } else if (type === 'suck') { 
                osc.type = 'sine'; osc.frequency.setValueAtTime(50, now); osc.frequency.linearRampToValueAtTime(10, now + 0.1);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.1); osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'charge') { 
                 osc.type = 'sine'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(500, now + 1.0);
                 gain.gain.setValueAtTime(0.0, now); gain.gain.linearRampToValueAtTime(0.2, now+0.5); gain.gain.linearRampToValueAtTime(0, now+1.0);
                 osc.start(now); osc.stop(now+1.0);
            } else if (type === 'boost') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(800, now + 0.4);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.4);
                osc.start(now); osc.stop(now+0.4);
            } else if (type === 'ion') { 
                osc.type = 'square'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(200, now + 0.5);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now); osc.stop(now+0.5);
            }
        } catch (e) { console.log("Audio Error", e); }
    }

    // --- MUSIC (Dark Ambient) ---
    let masterGain = null;
    let delayNode = null;
    let musicTimer = null;
    const AMB_SCALE = [146.83, 174.61, 196.00, 220.00, 261.63, 293.66, 349.23, 392.00]; 

    function setupAudio() {
        if(masterGain) return;
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.08; 
        
        delayNode = audioCtx.createDelay();
        delayNode.delayTime.value = 0.4;
        const feedback = audioCtx.createGain();
        feedback.gain.value = 0.4;
        delayNode.connect(feedback);
        feedback.connect(delayNode);
        
        delayNode.connect(masterGain);
        masterGain.connect(audioCtx.destination);
    }

    function playSynthNote(freq) {
        if(!masterGain) return;
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const noteGain = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.value = freq;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(0.3, now + 0.1);
        noteGain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
        osc.connect(noteGain);
        noteGain.connect(masterGain);
        noteGain.connect(delayNode); 
        osc.start(now);
        osc.stop(now + 1.5);
    }

    function musicStep() {
        if(!isMusicPlaying) return;
        let note = AMB_SCALE[Math.floor(Math.random() * AMB_SCALE.length)];
        if(Math.random() > 0.7) note *= 2;
        if(Math.random() > 0.9) note /= 2;
        playSynthNote(note);
        let nextTime = 200 + Math.random() * 400;
        musicTimer = setTimeout(musicStep, nextTime);
    }

    function startSoundtrack() {
        if(isMusicPlaying) return;
        setupAudio();
        isMusicPlaying = true;
        musicStep();
    }

    function startStarSound() {
        if (starOsc) return; 
        starOsc = audioCtx.createOscillator();
        starGain = audioCtx.createGain();
        starOsc.type = 'square';
        starOsc.frequency.setValueAtTime(150, audioCtx.currentTime);
        const lfo = audioCtx.createOscillator();
        lfo.type = 'sine'; lfo.frequency.value = 10; 
        const lfoGain = audioCtx.createGain(); lfoGain.gain.value = 500;
        lfo.connect(lfoGain); lfoGain.connect(starOsc.frequency);
        lfo.start();
        starOsc.connect(starGain); starGain.connect(audioCtx.destination);
        starGain.gain.value = 0.05; starOsc.start();
    }
    function stopStarSound() {
        if (starOsc) { try { starOsc.stop(); playSound('powerdown'); } catch(e) {} starOsc = null; starGain = null; }
    }

    // --- GAME STATE ---
    const slider = document.getElementById('diff-slider');
    const diffVal = document.getElementById('diff-val');
    let difficultyLevel = 2; 

    let state = 'SPLASH'; 
    let width, height;
    let lives = 3;
    let score = 0;
    let orientationSign = 1;

    let scoreMultiplier = 1;
    let lastScoreTime = 0;
    let lastWaveTime = 0; 

    let rawTiltBeta = 0, rawTiltGamma = 0; 
    let baseTiltBeta = 0, baseTiltGamma = 0; 

    let player = { x: 0, y: 0, vx: 0, vy: 0, size: 10.5, angle: 0 };
    let enemies = [];
    let diamonds = [];
    let powerups = [];
    let blackHoles = []; 
    let ionBlasts = [];
    let particles = [];
    let bgParticles = []; 
    let fireTrails = [];
    
    let shieldActive = false;
    let invincibilityTimer = 0;
    
    let boostTimer = 0;
    let boostOriginalVx = 0;
    let boostOriginalVy = 0;
    let spawnTimeout = null; 
    let pendingIon = 0;
    let directorTimer = 0;
    let formationMode = 'NONE'; 
    let formationStep = 0;

    // --- RESIZE & INIT ---
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        
        let angle = 0;
        if (screen.orientation && screen.orientation.angle) {
            angle = screen.orientation.angle;
        } else if (window.orientation) {
            angle = window.orientation;
        }

        if (height > width) {
            rotateMsg.style.display = 'flex';
            if(state === 'PLAYING') pauseGame();
        } else {
            rotateMsg.style.display = 'none';
            if (angle === -90 || angle === 270) orientationSign = -1;
            else orientationSign = 1;
        }
    }
    window.addEventListener('resize', resize);
    window.addEventListener('orientationchange', () => { setTimeout(resize, 200); });
    resize();

    for(let i=0; i<30; i++) {
        bgParticles.push({
            x: Math.random() * window.innerWidth,
            y: Math.random() * window.innerHeight,
            size: Math.random() * 25 + 5,
            speed: Math.random() * 0.4 + 0.1,
            type: Math.random() < 0.5 ? 'square' : 'triangle'
        });
    }

    uiSplash.style.display = 'flex';

    function splashHandler(e) {
        e.preventDefault();
        unlockAudio();
        uiSplash.style.display = 'none';
        uiStart.style.display = 'block';
        state = 'MENU';
        startSoundtrack(); 
    }
    uiSplash.addEventListener('click', splashHandler);
    uiSplash.addEventListener('touchstart', splashHandler);

    slider.addEventListener('input', (e) => {
        difficultyLevel = parseInt(e.target.value);
        if(difficultyLevel === 1) diffVal.innerText = "EASY";
        else if(difficultyLevel === 2) diffVal.innerText = "NORMAL";
        else diffVal.innerText = "HARD";
    });

    document.getElementById('start-btn').addEventListener('click', (e) => {
        e.stopPropagation(); 
        initPermsAndStart();
    });
    
    document.getElementById('retry-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        startCountdownSequence();
    });

    document.getElementById('resume-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        resumeGame();
    });

    // PAUSE LOGIC
    window.addEventListener('touchstart', (e) => {
        if(state !== 'PLAYING') return;
        if(e.target.tagName === 'BUTTON' || e.target.closest('.screen-box')) return;
        pauseGame();
    });
    window.addEventListener('mousedown', (e) => {
        if(state !== 'PLAYING') return;
        if(e.target.tagName === 'BUTTON' || e.target.closest('.screen-box')) return;
        pauseGame();
    });

    function pauseGame() {
        state = 'PAUSED';
        uiPause.style.display = 'block';
        if(starOsc) starOsc.disconnect();
        if(spawnTimeout) clearTimeout(spawnTimeout);
        if(musicTimer) clearTimeout(musicTimer);
        isMusicPlaying = false;
    }

    function resumeGame() {
        state = 'PLAYING';
        uiPause.style.display = 'none';
        if(invincibilityTimer > 0 && starOsc) starOsc.connect(starGain);
        spawnManager(); 
        isMusicPlaying = true;
        musicStep();
    }

    async function initPermsAndStart() {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const perm = await DeviceOrientationEvent.requestPermission();
                if (perm === 'granted') startCountdownSequence();
                else alert('Permission denied');
            } catch (e) { console.error(e); }
        } else {
            startCountdownSequence();
        }
    }

    window.addEventListener('deviceorientation', (e) => {
        if(e.gamma !== null) rawTiltGamma = e.gamma; 
        if(e.beta !== null) rawTiltBeta = e.beta;
    });

    // --- GAME LOOP HELPERS ---
    function nextCountdownStep(count) {
        const uiCountdown = document.getElementById('countdown-text');
        if (count > 0) {
            uiCountdown.innerText = count;
            playSound('beep');
            setTimeout(() => nextCountdownStep(count - 1), 1000);
        } else {
            uiCountdown.innerText = "GO!";
            playSound('go');
            
            // Zero Calibration
            baseTiltGamma = rawTiltGamma;
            baseTiltBeta = rawTiltBeta;

            setTimeout(() => {
                uiCountdown.style.display = 'none';
                state = 'PLAYING';
                spawnManager();
            }, 500);
        }
    }

    function startCountdownSequence() {
        const uiCountdown = document.getElementById('countdown-text');
        uiStart.style.display = 'none';
        uiGameOver.style.display = 'none';
        uiPause.style.display = 'none';
        uiCountdown.style.display = 'block';
        
        if(spawnTimeout) clearTimeout(spawnTimeout);

        if(difficultyLevel === 1) { 
            CONFIG.baseSpeed = 0.05;
            CONFIG.spawnRate = 0.02;
        } else if(difficultyLevel === 2) { 
            CONFIG.baseSpeed = 0.1;
            CONFIG.spawnRate = 0.04;
        } else { 
            CONFIG.baseSpeed = 0.15;
            CONFIG.spawnRate = 0.06;
        }

        enemies = []; 
        diamonds = []; 
        powerups = [];
        blackHoles = [];
        fireTrails = [];
        ionBlasts = [];
        
        if(lives <= 0 || state === 'MENU') {
            lives = 3; score = 0; 
            scoreMultiplier = 1; 
            startSoundtrack(); 
        }
        
        lastScoreTime = Date.now();
        lastWaveTime = Date.now();
        directorTimer = 0;
        formationMode = 'NONE';
        pendingIon = 0;
        
        player.x = width/2; player.y = height/2;
        player.vx = 0; player.vy = 0;
        shieldActive = false; invincibilityTimer = 0;
        boostTimer = 0;
        stopStarSound();

        updateHUD();
        state = 'COUNTDOWN';
        
        // Start recursive countdown (safer than interval)
        nextCountdownStep(3);
    }

    function spawnManager() {
        if (state !== 'PLAYING') return;
        if (formationMode !== 'NONE') {
            spawnTimeout = setTimeout(spawnManager, 500); 
            return;
        }
        
        let ramp = score * 0.000005; 
        
        if (Math.random() < CONFIG.spawnRate + ramp) spawnEnemy();
        if (Math.random() < 0.06) spawnDiamond(); 
        if (Math.random() < 0.016) spawnPowerup(); 
        
        spawnTimeout = setTimeout(spawnManager, 100); 
    }

    function spawnEnemy() {
        let ex, ey, dist;
        let safe = false;
        let attempts = 0;
        while(!safe && attempts < 10) {
            let edge = Math.floor(Math.random() * 4); 
            if(edge === 0) { ex = Math.random() * width; ey = -20; }
            else if(edge === 1) { ex = width + 20; ey = Math.random() * height; }
            else if(edge === 2) { ex = Math.random() * width; ey = height + 20; }
            else { ex = -20; ey = Math.random() * height; }
            dist = Math.hypot(player.x - ex, player.y - ey);
            if (dist > 300) safe = true; 
            attempts++;
        }
        
        let speed = CONFIG.baseSpeed;
        if (difficultyLevel === 1) speed += Math.log10(score + 2000) * 0.2; 
        else speed += Math.log(score + 2000) * 0.2;
        speed = Math.min(8.0, speed);
        
        enemies.push({ x: ex, y: ey, speed: speed, vx: 0, vy: 0, radius: 6, mode: 'IDLE' });
    }

    function spawnDiamond() {
        diamonds.push({ 
            x: Math.random() * (width-40) + 20, 
            y: Math.random() * (height-40) + 20, 
            vx: (Math.random() - 0.5) * 0.5, 
            vy: (Math.random() - 0.5) * 0.5,
            radius: 7.5 
        });
    }

    function spawnPowerup() {
        let r = Math.random();
        let type = 'SHIELD';
        if (r < 0.30) type = 'SHIELD';
        else if (r < 0.60) type = 'STAR';
        else if (r < 0.75) type = 'HOLE';
        else if (r < 0.85) type = 'FIRE';
        else type = 'ION';

        powerups.push({ 
            x: Math.random() * (width-40) + 20, 
            y: Math.random() * (height-40) + 20, 
            type: type,
            radius: 9 
        });
    }

    function spawnBlackHole(x, y) {
        playSound('charge');
        blackHoles.push({
            x: x,
            y: y,
            delay: CONFIG.blackHoleDelay, 
            life: CONFIG.blackHoleDuration, 
            angle: 0 
        });
    }

    function activateFireBooster() {
        playSound('boost');
        boostOriginalVx = player.vx;
        boostOriginalVy = player.vy;
        boostTimer = CONFIG.fireDuration; 
        invincibilityTimer = CONFIG.fireDuration + 200; 
    }

    function triggerIonBlast() {
        playSound('charge');
        pendingIon = CONFIG.ionDelay;
    }

    function fireIon() {
        playSound('ion');
        let vx = Math.cos(player.angle);
        let vy = Math.sin(player.angle);
        ionBlasts.push({
            x: player.x, y: player.y,
            vx: vx * CONFIG.ionSpeed, vy: vy * CONFIG.ionSpeed,
            radius: 10, maxRadius: CONFIG.ionMaxRadius
        });
    }

    function getShortestAngleDiff(current, target) {
        let diff = current - target;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return diff;
    }

    function scorePoints(points) {
        score += points * scoreMultiplier;
        lastScoreTime = Date.now();
        updateHUD();
    }

    function increaseMultiplier() {
        scoreMultiplier++;
        elCombo.classList.remove('pulse');
        void elCombo.offsetWidth; 
        elCombo.classList.add('pulse');
        lastScoreTime = Date.now();
        updateHUD();
    }

    function checkMagnet(item) {
        let dx = player.x - item.x;
        let dy = player.y - item.y;
        let distSq = dx*dx + dy*dy;
        if (distSq < CONFIG.magnetRadius * CONFIG.magnetRadius) {
            let dist = Math.sqrt(distSq);
            item.vx = (item.vx || 0) + (dx / dist) * CONFIG.magnetForce;
            item.vy = (item.vy || 0) + (dy / dist) * CONFIG.magnetForce;
            item.vx *= 0.9;
            item.vy *= 0.9;
            item.x += item.vx;
            item.y += item.vy;
        }
    }

    function triggerFormation() {
        let type = Math.random() < 0.5 ? 'ARROW' : 'WALL';
        const uiWarning = document.getElementById('formation-warning');
        uiWarning.style.display = 'block';
        setTimeout(() => uiWarning.style.display = 'none', 2000);
        
        if (type === 'ARROW') {
            formationMode = 'ARROW';
            formationStep = 0; 
            let squad = enemies.filter(e => e.mode === 'IDLE').slice(0, 12);
            while(squad.length < 12) { spawnEnemy(); squad.push(enemies[enemies.length-1]); }
            squad.forEach((e, i) => {
                e.mode = 'FORMATION';
                let row = Math.floor(i/2);
                let side = (i%2 === 0) ? -1 : 1;
                e.offsetX = side * row * 20; e.offsetY = row * -20; 
            });
            setTimeout(() => { formationStep = 1; playSound('charge'); }, 2000); 
            setTimeout(() => { formationStep = 2; playSound('boost'); }, 3000); 
            setTimeout(() => { formationMode = 'NONE'; enemies.forEach(e => { if(e.mode==='FORMATION') e.mode='IDLE'; }); }, 5000);
        } else {
            formationMode = 'WALL';
            let side = Math.random() < 0.5 ? 'LEFT' : 'RIGHT';
            let startX = (side === 'LEFT') ? -20 : width + 20;
            let velX = (side === 'LEFT') ? 1.5 : -1.5; 
            for(let i=0; i<15; i++) {
                let spacing = height / 16;
                enemies.push({ x: startX, y: (i+1) * spacing, speed: 0, vx: velX, vy: 0, radius: 6, mode: 'WALL_SWEEP' });
            }
            setTimeout(() => { formationMode = 'NONE'; }, 10000); 
        }
    }

    function update() {
        directorTimer++;
        if (directorTimer > 1200 && formationMode === 'NONE') {
            triggerFormation();
            directorTimer = 0;
        }
        if (pendingIon > 0) {
            pendingIon -= 16;
            if (pendingIon <= 0) fireIon();
        }
        let timeSinceScore = Date.now() - lastScoreTime;
        if (timeSinceScore > CONFIG.multiplierResetTime && scoreMultiplier > 1) {
            scoreMultiplier = 1;
            updateHUD();
        }
        let pct = Math.max(0, 100 - (timeSinceScore / CONFIG.multiplierResetTime * 100));
        elMultBar.style.width = pct + "%";
        
        // --- PLAYER PHYSICS ---
        if (boostTimer > 0) {
            let phase = CONFIG.fireDuration - boostTimer;
            if (phase < 100) {
                player.vx = Math.cos(player.angle) * CONFIG.maxVelocity;
                player.vy = Math.sin(player.angle) * CONFIG.maxVelocity;
            } else if (phase < 300) {
            } else {
                let t = (phase - 300) / 100; 
                player.vx = player.vx * (1-t) + boostOriginalVx * t;
                player.vy = player.vy * (1-t) + boostOriginalVy * t;
            }
            for(let k=0; k<3; k++) {
                fireTrails.push({
                    x: player.x + (Math.random()-0.5)*10, 
                    y: player.y + (Math.random()-0.5)*10,
                    life: CONFIG.fireTrailLife,
                    maxLife: CONFIG.fireTrailLife,
                    size: 10 + Math.random() * 20, 
                    angle: Math.random() * Math.PI * 2,
                    vx: (Math.random()-0.5)*0.5, 
                    vy: (Math.random()-0.5)*0.5
                });
            }
            boostTimer -= 16;
        } else {
            let diffX = getShortestAngleDiff(rawTiltBeta, baseTiltBeta); 
            let diffY = getShortestAngleDiff(rawTiltGamma, baseTiltGamma);

            if(diffX > CONFIG.maxTiltAngle) diffX = CONFIG.maxTiltAngle;
            if(diffX < -CONFIG.maxTiltAngle) diffX = -CONFIG.maxTiltAngle;
            if(diffY > CONFIG.maxTiltAngle) diffY = CONFIG.maxTiltAngle;
            if(diffY < -CONFIG.maxTiltAngle) diffY = -CONFIG.maxTiltAngle;

            let forceX = Math.sign(diffX) * Math.pow(Math.abs(diffX), CONFIG.inputExponent);
            let forceY = Math.sign(diffY) * Math.pow(Math.abs(diffY), CONFIG.inputExponent);

            // Dot Boost
            let speed = Math.sqrt(player.vx*player.vx + player.vy*player.vy);
            let vxNorm = (speed > 0.1) ? player.vx / speed : 0;
            let vyNorm = (speed > 0.1) ? player.vy / speed : 0;
            let totalForce = Math.hypot(forceX, forceY);
            let fxNorm = (totalForce > 0) ? (forceX) / totalForce : 0;
            let fyNorm = (totalForce > 0) ? (forceY) / totalForce : 0;
            let dot = (vxNorm * (fxNorm * orientationSign)) + (vyNorm * (-fyNorm * orientationSign));
            let turnFactor = 1 - Math.abs(dot); 
            let dynamicAccel = CONFIG.acceleration * (1 + (turnFactor * CONFIG.turnBoost));

            player.vx += forceX * dynamicAccel * orientationSign; 
            player.vy -= forceY * dynamicAccel * orientationSign; 

            player.vx *= CONFIG.friction;
            player.vy *= CONFIG.friction;

            if (speed > CONFIG.maxVelocity) {
                let ratio = CONFIG.maxVelocity / speed;
                player.vx *= ratio;
                player.vy *= ratio;
            }
        }
        
        player.x += player.vx;
        player.y += player.vy;
        
        if(player.x < 0) { player.x = 0; player.vx *= -0.5; }
        if(player.x > width) { player.x = width; player.vx *= -0.5; }
        if(player.y < 0) { player.y = 0; player.vy *= -0.5; }
        if(player.y > height) { player.y = height; player.vy *= -0.5; }

        if (Math.abs(player.vx) > 0.1 || Math.abs(player.vy) > 0.1) {
            player.angle = Math.atan2(player.vy, player.vx);
        }

        if (invincibilityTimer > 0) {
            invincibilityTimer -= 16;
            if (invincibilityTimer <= 1000 && starOsc) stopStarSound(); 
            if (invincibilityTimer <= 0) {
                invincibilityTimer = 0;
                stopStarSound();
            }
        }

        // --- ION BLASTS ---
        for (let i = ionBlasts.length - 1; i >= 0; i--) {
            let ion = ionBlasts[i];
            ion.x += ion.vx;
            ion.y += ion.vy;
            ion.radius += CONFIG.ionGrowth;
            if (ion.radius > ion.maxRadius) { ionBlasts.splice(i, 1); continue; }
            for (let j = enemies.length - 1; j >= 0; j--) {
                let e = enemies[j];
                if (Math.hypot(ion.x - e.x, ion.y - e.y) < ion.radius + e.radius) {
                    enemies.splice(j, 1); scorePoints(10); createExplosion(e.x, e.y, '#00ffff');
                }
            }
        }

        // --- FIRE TRAILS ---
        for (let i = fireTrails.length - 1; i >= 0; i--) {
            let f = fireTrails[i];
            f.life -= 16; f.x += f.vx; f.y += f.vy;
            if (f.life <= 0) { fireTrails.splice(i, 1); continue; }
            for (let j = enemies.length - 1; j >= 0; j--) {
                let e = enemies[j];
                if (Math.hypot(f.x - e.x, f.y - e.y) < (f.size * 0.8) + e.radius) {
                    enemies.splice(j, 1); scorePoints(10); createExplosion(e.x, e.y, '#e67e22');
                }
            }
        }

        // --- BLACK HOLE ---
        for (let i = blackHoles.length - 1; i >= 0; i--) {
            let bh = blackHoles[i];
            bh.angle += 0.2; 
            if (bh.delay > 0) { bh.delay -= 16; continue; }
            bh.life -= 16;
            if (bh.life <= 0) { blackHoles.splice(i, 1); continue; }
            for (let j = enemies.length - 1; j >= 0; j--) {
                let e = enemies[j];
                let dx = bh.x - e.x; let dy = bh.y - e.y;
                let distSq = dx*dx + dy*dy;
                if (Math.sqrt(distSq) < 20) { 
                    enemies.splice(j, 1); scorePoints(10); playSound('suck'); createExplosion(bh.x, bh.y, '#8e44ad', 5);
                } else {
                    let f = (CONFIG.blackHoleForce * 2.0 * 1500) / Math.max(distSq, 100);
                    e.x += (dx / Math.sqrt(distSq)) * f; e.y += (dy / Math.sqrt(distSq)) * f;
                }
            }
            for (let j = diamonds.length - 1; j >= 0; j--) {
                let d = diamonds[j];
                let dx = bh.x - d.x; let dy = bh.y - d.y;
                let distSq = dx*dx + dy*dy;
                if (distSq < 400) {
                    diamonds.splice(j, 1); scorePoints(1); increaseMultiplier(); playSound('suck');
                } else {
                    let f = (CONFIG.blackHoleForce * 1000) / Math.max(distSq, 100);
                    d.x += (dx / Math.sqrt(distSq)) * f; d.y += (dy / Math.sqrt(distSq)) * f;
                }
            }
            let pdx = bh.x - player.x; let pdy = bh.y - player.y;
            let pDistSq = pdx*pdx + pdy*pdy;
            let pDist = Math.sqrt(pDistSq);
            let pf = (CONFIG.blackHoleForce * 0.9 * 300) / Math.max(pDistSq, 100); 
            player.vx += (pdx / pDist) * pf; player.vy += (pdy / pDist) * pf;
        }

        // --- COLLISIONS ---
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            if (e.mode === 'IDLE') {
                if (invincibilityTimer <= 0) {
                    let dx = player.x - e.x; let dy = player.y - e.y; let dist = Math.sqrt(dx*dx + dy*dy);
                    e.vx = (dx / dist) * e.speed; e.vy = (dy / dist) * e.speed;
                } else { e.vx *= 0.95; e.vy *= 0.95; }
            } else if (e.mode === 'FORMATION') {
                if (formationStep === 0) {
                    let tx = (width/2) + e.offsetX; let ty = 100 + e.offsetY; 
                    let dx = tx - e.x; let dy = ty - e.y;
                    e.vx = dx * 0.05; e.vy = dy * 0.05;
                } else if (formationStep === 1) { e.vx = 0; e.vy = 0; } else if (formationStep === 2) {
                    if (e.vx === 0) {
                        let dx = player.x - e.x; let dy = player.y - e.y; let dist = Math.hypot(dx, dy);
                        e.vx = (dx/dist) * 12; e.vy = (dy/dist) * 12;
                    }
                }
            }
            e.x += e.vx; e.y += e.vy;
            let hitDist = (shieldActive || invincibilityTimer > 0) ? CONFIG.shieldRadius : (player.size * CONFIG.hitboxRatio);
            let pDist = Math.hypot(player.x - e.x, player.y - e.y);
            if (pDist < hitDist + (e.radius * CONFIG.enemyHitboxRatio)) {
                if (invincibilityTimer > 0) {
                    enemies.splice(i, 1); scorePoints(10); createExplosion(e.x, e.y, '#f1c40f'); playSound('crash');
                } else if (shieldActive) {
                    shieldActive = false; createExplosion(player.x, player.y, '#3498db'); playSound('crash'); destroyEnemiesInRange(150);
                } else { killPlayer(); }
            }
        }
        for (let i = diamonds.length - 1; i >= 0; i--) {
            let d = diamonds[i];
            checkMagnet(d); 
            d.x += d.vx; d.y += d.vy;
            if(d.x < 0 || d.x > width) d.vx *= -1; if(d.y < 0 || d.y > height) d.vy *= -1;
            let dist = Math.hypot(player.x - d.x, player.y - d.y);
            if (dist < player.size + CONFIG.diamondHitbox) {
                scorePoints(1); increaseMultiplier(); playSound('coin'); diamonds.splice(i, 1);
            }
        }
        for (let i = powerups.length - 1; i >= 0; i--) {
            let p = powerups[i];
            checkMagnet(p); 
            let dist = Math.hypot(player.x - p.x, player.y - p.y);
            if (dist < player.size + p.radius) {
                playSound('powerup');
                if(p.type === 'SHIELD') shieldActive = true;
                if(p.type === 'STAR') { invincibilityTimer = CONFIG.invincibilityTime; startStarSound(); }
                if(p.type === 'HOLE') spawnBlackHole(p.x, p.y);
                if(p.type === 'FIRE') activateFireBooster();
                if(p.type === 'ION') triggerIonBlast();
                powerups.splice(i, 1);
            }
        }
        updateParticles();
        bgParticles.forEach(p => { p.y += p.speed; if(p.y > height) p.y = -50; });
    }

    function gameLoop() {
        requestAnimationFrame(gameLoop);
        if(state === 'PLAYING') { update(); draw(); } else if (state === 'DYING') { updateParticles(); draw(); } else if (state === 'COUNTDOWN' || state === 'PAUSED' || state === 'GAMEOVER' || state === 'SPLASH' || state === 'MENU') { draw(); }
    }
    
    requestAnimationFrame(gameLoop);

</script>
</body>
</html>
