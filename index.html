<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Tilt to Thrive</title>
    <style>
        /* --- CORE STYLES --- */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #051e11; 
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; 
            user-select: none; 
            -webkit-user-select: none; 
        }
        canvas { display: block; }
        
        /* --- UI LAYER --- */
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            text-align: center; 
            z-index: 10;
        }

        /* --- HUD --- */
        #hud-top { 
            position: absolute; 
            top: max(10px, env(safe-area-inset-top)); 
            left: max(15px, env(safe-area-inset-left)); 
            right: max(15px, env(safe-area-inset-right)); 
            display: flex; 
            justify-content: space-between; 
            pointer-events: none; 
        }
        
        .hud-text { 
            font-size: 18px; 
            font-weight: bold; 
            color: #ecf0f1; 
            text-shadow: 1px 1px 0 #000;
        }
        
        #combo-display { 
            color: #f1c40f; 
            font-size: 22px; 
            text-shadow: 0 0 10px rgba(241, 196, 15, 0.8); 
            transition: transform 0.1s; 
        }
        .pulse { transform: scale(1.5); }

        /* --- CONTROLS --- */
        button { 
            pointer-events: auto; 
            padding: 15px 40px; 
            font-size: 20px; 
            font-family: sans-serif;
            font-weight: 800;
            background: linear-gradient(to bottom, #2ecc71, #27ae60); 
            color: white; 
            border: 2px solid #fff; 
            border-radius: 50px; 
            cursor: pointer; 
            box-shadow: 0 0 15px #27ae60; 
            transition: transform 0.1s; 
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        button:active { transform: scale(0.95); }
        button.red { background: linear-gradient(to bottom, #e74c3c, #c0392b); box-shadow: 0 0 15px #c0392b; }

        /* Slider */
        .slider-container { margin-bottom: 20px; pointer-events: auto; width: 200px; }
        input[type=range] { width: 100%; accent-color: #f1c40f; }
        .diff-label { color: #f1c40f; font-weight: bold; margin-top: 5px; display: block; font-family: sans-serif; }

        /* --- SCREENS --- */
        .screen-box {
            pointer-events: auto; 
            background: rgba(5, 25, 10, 0.95); 
            padding: 30px; 
            border-radius: 20px; 
            border: 2px solid #2ecc71; 
            box-shadow: 0 0 30px rgba(46, 204, 113, 0.3);
            max-width: 80%;
        }

        #start-screen, #game-over, #pause-screen, #level-screen { display: none; }
        
        /* --- SPLASH ART STYLING --- */
        #splash-screen {
            pointer-events: auto; 
            cursor: pointer;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #splash-img {
            width: 100%;
            height: 100%;
            object-fit: contain; 
            z-index: 0;
        }

        .splash-overlay {
            position: absolute;
            bottom: 10%;
            width: 100%;
            text-align: center;
            z-index: 2;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        
        .instruction-text { font-size: 18px; color: #fff; margin: 0; font-family: sans-serif; font-weight: bold; opacity: 0.8; }
        
        /* Rotation Warning Overlay */
        #rotate-msg { 
            display: none; 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: #000; 
            z-index: 9999; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            color: white; 
            font-family: sans-serif;
        }
        
        @media screen and (orientation: portrait) {
            #rotate-msg { display: flex !important; }
        }

        /* Multiplier Bar */
        #mult-bar-container { position: absolute; top: 40px; left: 15px; width: 100px; height: 6px; background: rgba(0,0,0,0.5); border: 1px solid #555; border-radius: 4px; display: none; }
        #mult-bar-fill { height: 100%; width: 100%; background: linear-gradient(90deg, #f1c40f, #e67e22); border-radius: 3px; transition: width 0.1s linear; }
        
        /* Copyright Footer */
        #copyright { margin-top: 5px; color: rgba(255,255,255,0.5); font-size: 12px; font-family: sans-serif; }
        
        #formation-warning {
            display: none;
            position: absolute;
            top: 30%;
            width: 100%;
            text-align: center;
            font-size: 40px;
            color: #e74c3c;
            font-weight: 900;
            text-shadow: 0 0 20px red;
            pointer-events: none;
            animation: flash 0.5s infinite;
        }
        @keyframes flash { 0% {opacity:0;} 50% {opacity:1;} 100% {opacity:0;} }

        /* BUBBLE LEVEL UI */
        #level-container {
            position: relative;
            width: 300px;
            height: 300px;
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
            border: 2px solid #555;
            margin: 0 auto 20px auto;
        }
        
        /* The Safe Zone (Target) */
        #level-target {
            position: absolute;
            top: 50%; left: 50%;
            width: 60px;  
            height: 60px; 
            border: 4px solid #e74c3c;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.2);
            transition: border-color 0.2s;
        }
        
        /* The Bubble */
        #level-dot {
            position: absolute;
            top: 50%; left: 50%;
            width: 40px; height: 40px;
            background: #e74c3c;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: background 0.1s;
            box-shadow: 0 0 10px currentColor;
        }
    </style>
</head>
<body>

    <div id="rotate-msg">
        <img src="icon.jpg" style="width: 150px; height: 150px; border-radius: 30px; margin-bottom: 20px; box-shadow: 0 0 30px #00c6ff;">
        <div style="font-size: 50px; color:#00c6ff; margin: 20px;">⟳</div>
        <p style="color:white; font-size: 24px; font-weight:bold;">Rotate to Landscape</p>
    </div>

    <div id="hud-top">
        <div style="text-align:left;">
            <div id="score-display" class="hud-text">SCORE: 0</div>
            <div id="combo-display" class="hud-text">1x</div>
            <div id="mult-bar-container"><div id="mult-bar-fill"></div></div>
        </div>
        <div id="lives-display" class="hud-text">❤❤❤</div>
    </div>
    
    <div id="ui-layer">
        <h2 id="countdown-text" style="font-size: 100px; color: #fff; text-shadow: 0 0 20px #f1c40f; display:none;">3</h2>
        <div id="formation-warning">⚠ SWARM DETECTED ⚠</div>

        <div id="splash-screen">
            <img id="splash-img" src="splash.jpg" alt="Tilt to Thrive">
            <div class="splash-overlay">
                <p class="instruction-text" style="color: #bdc3c7;">Tap anywhere to begin</p>
                <div id="copyright">© 2025 Steve Elkins</div>
            </div>
        </div>

        <div id="start-screen" class="screen-box">
            <h2 style="margin:0 0 15px 0; color:#2ecc71; display:block;">MISSION</h2>
            <p class="instruction-text" style="margin-bottom: 20px;">
                Avoid the Red Dots<br>
                Collect Yellow Diamonds<br>
                Grab Golden Powerups
            </p>
            
            <div class="slider-container" style="margin: 0 auto 20px auto;">
                <label for="diff-slider" style="color:white; font-family:sans-serif;">Difficulty</label>
                <input type="range" min="1" max="3" value="1" id="diff-slider">
                <span id="diff-val" class="diff-label">EASY</span>
            </div>

            <button id="start-btn">LAUNCH</button>
        </div>

        <div id="level-screen" class="screen-box">
            <h2 style="color:white; margin-top:0;">CALIBRATION</h2>
            <div id="level-container">
                <div id="level-target"></div>
                <div id="level-dot"></div>
            </div>
            <p style="color: #bdc3c7;">Center the Bubble to Start</p>
            <p style="font-size:12px; color:#555;">(Hold phone at comfortable reading angle)</p>
        </div>

        <div id="pause-screen" class="screen-box">
            <h1 style="color:white; font-family:sans-serif;">PAUSED</h1>
            <button id="resume-btn">RESUME</button>
        </div>
        
        <div id="game-over" class="screen-box">
            <h1 style="color: #e74c3c; font-family:sans-serif;">CRITICAL FAILURE</h1>
            <p id="final-score" style="color:white; font-size: 24px;">Score: 0</p>
            <button class="red" id="retry-btn">RETRY</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    // --- CONFIG ---
    const CONFIG = {
        friction: 0.95,         
        acceleration: 0.006,    
        inputExponent: 1.3,     
        maxVelocity: 11.0,
        maxTiltAngle: 35,
        turnBoost: 1.5,         
        
        baseSpeed: 0.1, 
        spawnRate: 0.05,
        waveDuration: 60000,
        
        hitboxRatio: 0.55,
        enemyHitboxRatio: 0.45, 
        diamondHitbox: 15,
        magnetRadius: 50,       
        magnetForce: 0.5,       
        
        shieldRadius: 24,       
        invincibilityTime: 8000,
        
        blackHoleDuration: 10000,
        blackHoleDelay: 2000,   
        blackHoleForce: 0.6,    
        
        fireDuration: 400,      
        fireTrailLife: 7000,    
        fireRadius: 25,         
        
        ionDelay: 1000,         
        ionSpeed: 14,           
        ionGrowth: 1.0,         
        ionMaxRadius: 300,      // Huge
        
        multiplierResetTime: 15000 
    };

    // --- AUDIO ENGINE ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let starOsc = null; 
    let starGain = null;

    let isMusicPlaying = false;
    let musicStartTime = 0;
    let schedulerTimer;
    const MUSIC_TOTAL_DURATION = 300; 
    const C = 261.63, D = 293.66, E = 329.63, F = 349.23, G = 392.00, A = 440.00, B = 493.88;
    const CHORD_PROGRESSION = [[C, E, G], [G, B, D*2], [A, C*2, E*2], [F, A, C*2]];
    let seqState = { chordIndex: 0, noteIndex: 0, beatCounter: 0 };

    function unlockAudio() {
        if (audioCtx.state === 'suspended') { audioCtx.resume(); }
        const buffer = audioCtx.createBuffer(1, 1, 22050); 
        const source = audioCtx.createBufferSource(); 
        source.buffer = buffer; 
        source.connect(audioCtx.destination); 
        source.start(0); 
    }

    function startSoundtrack() {
        if(isMusicPlaying) return;
        isMusicPlaying = true;
        musicStartTime = audioCtx.currentTime - (MUSIC_TOTAL_DURATION * 0.3); 
        scheduleNextBeat();
    }

    function playEnvelopeNote(frequency, duration, type, attack, release) {
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(frequency, now);
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(0.02, now + attack); 
        gainNode.gain.setValueAtTime(0.02, now + duration - release);
        gainNode.gain.linearRampToValueAtTime(0, now + duration);
        osc.connect(gainNode); gainNode.connect(audioCtx.destination);
        osc.start(now); osc.stop(now + duration + 0.1); 
    }

    function scheduleNextBeat() {
        if(!isMusicPlaying) return;
        const elapsed = audioCtx.currentTime - musicStartTime;
        const progress = Math.min(elapsed / MUSIC_TOTAL_DURATION, 1.0);
        const currentBPM = 60 + (progress * (320 - 60));
        const secondsPerBeat = 60.0 / currentBPM;

        if (progress < 0.7) {
            let baseFreq = CHORD_PROGRESSION[seqState.chordIndex][seqState.noteIndex];
            playEnvelopeNote(baseFreq, secondsPerBeat * 0.8, 'triangle', 0.05, 0.1);
            seqState.noteIndex = (seqState.noteIndex + 1) % 3;
        } else {
            let octave = (seqState.beatCounter % 2 === 0) ? 1 : 2; 
            if (Math.random() > 0.8) octave = 3;
            let baseFreq = CHORD_PROGRESSION[seqState.chordIndex][seqState.noteIndex];
            playEnvelopeNote(baseFreq * octave, secondsPerBeat * 0.3, 'triangle', 0.01, 0.05);
            seqState.noteIndex = (seqState.noteIndex + 1) % 3;
        }
        seqState.beatCounter++;
        if (seqState.beatCounter % 4 === 0) {
            seqState.chordIndex = (seqState.chordIndex + 1) % CHORD_PROGRESSION.length;
            if (progress < 0.7) seqState.noteIndex = 0; 
        }
        schedulerTimer = setTimeout(scheduleNextBeat, secondsPerBeat * 1000);
    }

    function playSound(type) {
        if (audioCtx.state === 'suspended') return;
        try {
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'beep') { 
                osc.type = 'square'; osc.frequency.setValueAtTime(440, now); osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.1);
                gain.gain.setValueAtTime(0.1, now); osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'go') { 
                osc.type = 'square'; osc.frequency.setValueAtTime(880, now); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                osc.start(now); osc.stop(now + 0.4);
            } else if (type === 'coin') { 
                osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.linearRampToValueAtTime(1800, now + 0.1);
                gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'crash') { 
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.5);
                gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5); osc.start(now); osc.stop(now + 0.5);
            } else if (type === 'powerup') { 
                osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); osc.frequency.linearRampToValueAtTime(800, now + 0.3);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'powerdown') { 
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(100, now + 0.5);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5);
            } else if (type === 'suck') { 
                osc.type = 'sine'; osc.frequency.setValueAtTime(50, now); osc.frequency.linearRampToValueAtTime(10, now + 0.1);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.1); osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'charge') { 
                 osc.type = 'sine'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(500, now + 1.0);
                 gain.gain.setValueAtTime(0.0, now); gain.gain.linearRampToValueAtTime(0.2, now+0.5); gain.gain.linearRampToValueAtTime(0, now+1.0);
                 osc.start(now); osc.stop(now+1.0);
            } else if (type === 'boost') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(800, now + 0.4);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.4);
                osc.start(now); osc.stop(now+0.4);
            } else if (type === 'ion') { 
                osc.type = 'square'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(200, now + 0.5);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now); osc.stop(now+0.5);
            } else if (type === 'dbomb') { 
                osc.type = 'triangle'; osc.frequency.setValueAtTime(600, now); osc.frequency.exponentialRampToValueAtTime(1200, now + 0.3);
                gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now+0.3);
            }
        } catch(e) {}
    }

    function startStarSound() {
        if (starOsc) return; 
        starOsc = audioCtx.createOscillator();
        starGain = audioCtx.createGain();
        starOsc.type = 'square';
        starOsc.frequency.setValueAtTime(150, audioCtx.currentTime);
        const lfo = audioCtx.createOscillator();
        lfo.type = 'sine'; lfo.frequency.value = 10; 
        const lfoGain = audioCtx.createGain(); lfoGain.gain.value = 500;
        lfo.connect(lfoGain); lfoGain.connect(starOsc.frequency);
        lfo.start();
        starOsc.connect(starGain); starGain.connect(audioCtx.destination);
        starGain.gain.value = 0.05; starOsc.start();
    }
    function stopStarSound() {
        if (starOsc) { try { starOsc.stop(); playSound('powerdown'); } catch(e) {} starOsc = null; starGain = null; }
    }

    // --- SETUP ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const uiSplash = document.getElementById('splash-screen');
    const uiStart = document.getElementById('start-screen');
    const uiPause = document.getElementById('pause-screen');
    const uiGameOver = document.getElementById('game-over');
    const uiLevel = document.getElementById('level-screen');
    const uiCountdown = document.getElementById('countdown-text');
    const elScore = document.getElementById('score-display');
    const elCombo = document.getElementById('combo-display');
    const elLives = document.getElementById('lives-display');
    const rotateMsg = document.getElementById('rotate-msg');
    const elMultBar = document.getElementById('mult-bar-fill');
    const elMultContainer = document.getElementById('mult-bar-container');
    const uiWarning = document.getElementById('formation-warning');
    
    // Level Elements
    const levelDot = document.getElementById('level-dot');
    const levelTarget = document.getElementById('level-target');

    const slider = document.getElementById('diff-slider');
    const diffVal = document.getElementById('diff-val');
    let difficultyLevel = 1; // Default Easy

    let state = 'SPLASH'; 
    let width, height;
    let lives = 3;
    let score = 0;
    let orientationSign = 1;

    let scoreMultiplier = 1;
    let lastScoreTime = 0;
    let lastWaveTime = 0; 

    let rawTiltBeta = 0, rawTiltGamma = 0; 
    let baseTiltBeta = 0, baseTiltGamma = 0; 

    let player = { x: 0, y: 0, vx: 0, vy: 0, size: 10.5, angle: 0 };
    let enemies = [];
    let diamonds = [];
    let powerups = [];
    let blackHoles = []; 
    let ionBlasts = [];
    let particles = [];
    let bgParticles = []; 
    let fireTrails = [];
    
    let shieldActive = false;
    let invincibilityTimer = 0;
    
    let boostTimer = 0;
    let boostOriginalVx = 0;
    let boostOriginalVy = 0;
    let spawnTimeout = null; 
    let pendingIon = 0;
    let directorTimer = 0;
    let formationMode = 'NONE'; 
    let formationStep = 0;
    let levelRaf = null;

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        
        let angle = 0;
        if (screen.orientation && screen.orientation.angle) {
            angle = screen.orientation.angle;
        } else if (window.orientation) {
            angle = window.orientation;
        }

        if (height > width) {
            rotateMsg.style.display = 'flex';
            if(state === 'PLAYING') pauseGame();
        } else {
            rotateMsg.style.display = 'none';
            if (angle === -90 || angle === 270) {
                orientationSign = -1;
            } else {
                orientationSign = 1;
            }
        }
    }
    window.addEventListener('resize', resize);
    window.addEventListener('orientationchange', () => { setTimeout(resize, 200); });
    resize();

    for(let i=0; i<30; i++) {
        bgParticles.push({
            x: Math.random() * window.innerWidth,
            y: Math.random() * window.innerHeight,
            size: Math.random() * 25 + 5,
            speed: Math.random() * 0.4 + 0.1,
            type: Math.random() < 0.5 ? 'square' : 'triangle'
        });
    }

    uiSplash.style.display = 'flex';

    function splashHandler(e) {
        e.preventDefault();
        unlockAudio();
        uiSplash.style.display = 'none';
        uiStart.style.display = 'block';
        state = 'MENU';
        // Set default easy
        diffVal.innerText = "EASY";
        slider.value = 1;
    }
    uiSplash.addEventListener('click', splashHandler);
    uiSplash.addEventListener('touchstart', splashHandler);

    slider.addEventListener('input', (e) => {
        difficultyLevel = parseInt(e.target.value);
        if(difficultyLevel === 1) diffVal.innerText = "EASY";
        else if(difficultyLevel === 2) diffVal.innerText = "NORMAL";
        else diffVal.innerText = "HARD";
    });

    document.getElementById('start-btn').addEventListener('click', (e) => {
        e.stopPropagation(); 
        initPermsAndStart();
    });
    
    document.getElementById('retry-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        startCountdownSequence();
    });

    document.getElementById('resume-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        resumeGame();
    });

    window.addEventListener('touchstart', (e) => {
        if(state !== 'PLAYING') return;
        if(e.target.tagName === 'BUTTON' || e.target.closest('.screen-box')) return;
        pauseGame();
    });
    window.addEventListener('mousedown', (e) => {
        if(state !== 'PLAYING') return;
        if(e.target.tagName === 'BUTTON' || e.target.closest('.screen-box')) return;
        pauseGame();
    });

    function pauseGame() {
        state = 'PAUSED';
        uiPause.style.display = 'block';
        if(starOsc) starOsc.disconnect();
        if(spawnTimeout) clearTimeout(spawnTimeout);
        if(schedulerTimer) clearTimeout(schedulerTimer);
        isMusicPlaying = false;
    }

    function resumeGame() {
        state = 'PLAYING';
        uiPause.style.display = 'none';
        if(invincibilityTimer > 0 && starOsc) starOsc.connect(starGain);
        spawnManager(); 
        isMusicPlaying = true;
        scheduleNextBeat();
    }

    async function initPermsAndStart() {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const perm = await DeviceOrientationEvent.requestPermission();
                if (perm === 'granted') checkLevelAndStart();
                else alert('Permission denied');
            } catch (e) { console.error(e); }
        } else {
            checkLevelAndStart();
        }
    }

    window.addEventListener('deviceorientation', (e) => {
        if(e.gamma !== null) rawTiltGamma = e.gamma; 
        if(e.beta !== null) rawTiltBeta = e.beta;
    });

    function checkLevelAndStart() {
        // Center target around Beta 45 (Holding)
        // Accept range 20 to 70 deg Beta (+/- 25)
        // Accept Gamma +/- 5
        
        let validY = (rawTiltBeta >= 20 && rawTiltBeta <= 70);
        let validX = (Math.abs(rawTiltGamma) <= 5);

        if (!validX || !validY) {
            uiStart.style.display = 'none';
            uiLevel.style.display = 'block';
            runLevelLoop();
        } else {
            startCountdownSequence();
        }
    }

    function runLevelLoop() {
        // Map Raw Beta (Target 45) to Screen Y (0 center)
        // Range +/- 30 degrees covers 150px
        let by = (rawTiltBeta - 45) * 5; 
        
        // Map Raw Gamma (Target 0)
        let bx = rawTiltGamma * 10;

        if(orientationSign === 1) {
             levelDot.style.transform = `translate(calc(-50% + ${by}px), calc(-50% + ${bx}px))`;
        } else {
             levelDot.style.transform = `translate(calc(-50% - ${by}px), calc(-50% - ${bx}px))`;
        }

        let validY = (rawTiltBeta >= 20 && rawTiltBeta <= 70);
        let validX = (Math.abs(rawTiltGamma) <= 5);

        if (validX && validY) {
            levelDot.style.background = '#2ecc71';
            levelTarget.style.borderColor = '#2ecc71';
            setTimeout(() => {
                cancelAnimationFrame(levelRaf);
                uiLevel.style.display = 'none';
                startCountdownSequence();
            }, 500);
        } else {
             levelDot.style.background = '#e74c3c';
             levelTarget.style.borderColor = '#e74c3c';
             levelRaf = requestAnimationFrame(runLevelLoop);
        }
    }

    function nextCountdownStep(count) {
        const uiCountdown = document.getElementById('countdown-text');
        if (count > 0) {
            uiCountdown.innerText = count;
            playSound('beep');
            setTimeout(() => nextCountdownStep(count - 1), 1000);
        } else {
            uiCountdown.innerText = "GO!";
            playSound('go');
            
            baseTiltGamma = rawTiltGamma;
            baseTiltBeta = rawTiltBeta;

            setTimeout(() => {
                uiCountdown.style.display = 'none';
                state = 'PLAYING';
                spawnManager();
            }, 500);
        }
    }

    function startCountdownSequence() {
        const uiCountdown = document.getElementById('countdown-text');
        uiStart.style.display = 'none';
        uiGameOver.style.display = 'none';
        uiPause.style.display = 'none';
        uiLevel.style.display = 'none';
        uiCountdown.style.display = 'block';
        
        if(spawnTimeout) clearTimeout(spawnTimeout);

        if(difficultyLevel === 1) { 
            CONFIG.baseSpeed = 0.02; // SLOWER
            CONFIG.spawnRate = 0.02;
        } else if(difficultyLevel === 2) { 
            CONFIG.baseSpeed = 0.1;
            CONFIG.spawnRate = 0.04;
        } else { 
            CONFIG.baseSpeed = 0.15;
            CONFIG.spawnRate = 0.06;
        }

        enemies = []; 
        diamonds = []; 
        powerups = [];
        blackHoles = [];
        fireTrails = [];
        ionBlasts = [];
        
        if(lives <= 0 || state === 'MENU') {
            lives = 3; score = 0; 
            scoreMultiplier = 1; 
            startSoundtrack(); 
        }
        
        lastScoreTime = Date.now();
        lastWaveTime = Date.now();
        directorTimer = 0;
        formationMode = 'NONE';
        pendingIon = 0;
        
        player.x = width/2; player.y = height/2;
        player.vx = 0; player.vy = 0;
        shieldActive = false; invincibilityTimer = 0;
        boostTimer = 0;
        stopStarSound();

        updateHUD();
        state = 'COUNTDOWN';
        
        nextCountdownStep(3);
    }

    function spawnManager() {
        if (state !== 'PLAYING') return;
        if (formationMode !== 'NONE') {
            spawnTimeout = setTimeout(spawnManager, 500); 
            return;
        }
        
        let ramp = score * 0.000005; 
        
        if (Math.random() < CONFIG.spawnRate + ramp) spawnEnemy();
        if (Math.random() < 0.06) spawnDiamond(); 
        if (Math.random() < 0.016) spawnPowerup(); 
        
        spawnTimeout = setTimeout(spawnManager, 100); 
    }

    function spawnEnemy() {
        let ex, ey, dist;
        let safe = false;
        let attempts = 0;
        while(!safe && attempts < 10) {
            let edge = Math.floor(Math.random() * 4); 
            if(edge === 0) { ex = Math.random() * width; ey = -20; }
            else if(edge === 1) { ex = width + 20; ey = Math.random() * height; }
            else if(edge === 2) { ex = Math.random() * width; ey = height + 20; }
            else { ex = -20; ey = Math.random() * height; }
            dist = Math.hypot(player.x - ex, player.y - ey);
            if (dist > 300) safe = true; 
            attempts++;
        }
        
        let speed = CONFIG.baseSpeed;
        if (difficultyLevel === 1) speed += Math.log10(score + 2000) * 0.2; 
        else speed += Math.log(score + 2000) * 0.2;
        speed = Math.min(8.0, speed);
        
        enemies.push({ x: ex, y: ey, speed: speed, vx: 0, vy: 0, radius: 6, mode: 'IDLE' });
    }

    function spawnDiamond() {
        diamonds.push({ 
            x: Math.random() * (width-40) + 20, 
            y: Math.random() * (height-40) + 20, 
            vx: (Math.random() - 0.5) * 0.5, 
            vy: (Math.random() - 0.5) * 0.5,
            radius: 7.5 
        });
    }

    function spawnPowerup() {
        let r = Math.random();
        let type = 'SHIELD';
        
        // Distribution
        if (r < 0.25) type = 'SHIELD';
        else if (r < 0.50) type = 'STAR';
        else if (r < 0.65) type = 'HOLE';
        else if (r < 0.75) type = 'FIRE';
        else if (r < 0.85) type = 'ION';
        else type = 'DIAMOND_BOMB'; // 15% chance

        powerups.push({ 
            x: Math.random() * (width-40) + 20, 
            y: Math.random() * (height-40) + 20, 
            type: type,
            radius: (type==='DIAMOND_BOMB') ? 12 : 9 
        });
    }

    function spawnBlackHole(x, y) {
        playSound('charge');
        blackHoles.push({
            x: x,
            y: y,
            delay: CONFIG.blackHoleDelay, 
            life: CONFIG.blackHoleDuration, 
            angle: 0 
        });
    }

    function activateFireBooster() {
        playSound('boost');
        boostOriginalVx = player.vx;
        boostOriginalVy = player.vy;
        boostTimer = CONFIG.fireDuration; 
        invincibilityTimer = CONFIG.fireDuration + 400; // Extra buffer
    }

    function activateDiamondBomb() {
        playSound('dbomb');
        setTimeout(() => {
            for(let i=0; i<25; i++) {
                let angle = (Math.PI * 2 / 25) * i;
                let speed = 12 + Math.random() * 4;
                diamonds.push({
                    x: player.x, y: player.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 7.5,
                    isProjectile: true,
                    projectileTimer: 60 // 1 second immunity
                });
            }
        }, 250);
    }

    function triggerIonBlast() {
        playSound('charge');
        pendingIon = CONFIG.ionDelay;
    }

    function fireIon() {
        playSound('ion');
        let vx = Math.cos(player.angle);
        let vy = Math.sin(player.angle);
        ionBlasts.push({
            x: player.x, y: player.y,
            vx: vx * CONFIG.ionSpeed, vy: vy * CONFIG.ionSpeed,
            radius: 10, maxRadius: CONFIG.ionMaxRadius
        });
    }

    function getShortestAngleDiff(current, target) {
        let diff = current - target;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return diff;
    }

    function scorePoints(points) {
        score += points * scoreMultiplier;
        lastScoreTime = Date.now();
        updateHUD();
    }

    function increaseMultiplier() {
        scoreMultiplier++;
        elCombo.classList.remove('pulse');
        void elCombo.offsetWidth; 
        elCombo.classList.add('pulse');
        lastScoreTime = Date.now();
        updateHUD();
    }

    function checkMagnet(item) {
        if(item.isProjectile && item.projectileTimer > 0) return;

        let dx = player.x - item.x;
        let dy = player.y - item.y;
        let distSq = dx*dx + dy*dy;
        if (distSq < CONFIG.magnetRadius * CONFIG.magnetRadius) {
            let dist = Math.sqrt(distSq);
            item.vx = (item.vx || 0) + (dx / dist) * CONFIG.magnetForce;
            item.vy = (item.vy || 0) + (dy / dist) * CONFIG.magnetForce;
            item.vx *= 0.9;
            item.vy *= 0.9;
            item.x += item.vx;
            item.y += item.vy;
        }
    }

    function triggerFormation() {
        let type = Math.random() < 0.5 ? 'ARROW' : 'WALL';
        const uiWarning = document.getElementById('formation-warning');
        uiWarning.style.display = 'block';
        setTimeout(() => uiWarning.style.display = 'none', 2000);
        
        if (type === 'ARROW') {
            formationMode = 'ARROW';
            formationStep = 0; 
            let squad = enemies.filter(e => e.mode === 'IDLE').slice(0, 12);
            while(squad.length < 12) { spawnEnemy(); squad.push(enemies[enemies.length-1]); }
            squad.forEach((e, i) => {
                e.mode = 'FORMATION';
                let row = Math.floor(i/2);
                let side = (i%2 === 0) ? -1 : 1;
                e.offsetX = side * row * 10; 
                e.offsetY = row * -10; 
            });
            setTimeout(() => { formationStep = 1; playSound('charge'); }, 2000); 
            setTimeout(() => { formationStep = 2; playSound('boost'); }, 3000); 
            setTimeout(() => { formationMode = 'NONE'; enemies.forEach(e => { if(e.mode==='FORMATION') e.mode='IDLE'; }); }, 5000);
        } else {
            formationMode = 'WALL';
            let side = Math.random() < 0.5 ? 'LEFT' : 'RIGHT';
            let startX = (side === 'LEFT') ? -20 : width + 20;
            let velX = (side === 'LEFT') ? 1.5 : -1.5; 
            for(let i=0; i<15; i++) {
                let spacing = height / 16;
                enemies.push({ x: startX, y: (i+1) * spacing, speed: 0, vx: velX, vy: 0, radius: 6, mode: 'WALL_SWEEP' });
            }
            setTimeout(() => { formationMode = 'NONE'; }, 10000); 
        }
    }

    function update() {
        directorTimer++;
        if (directorTimer > 1200 && formationMode === 'NONE') {
            triggerFormation();
            directorTimer = 0;
        }
        if (pendingIon > 0) {
            pendingIon -= 16;
            if (pendingIon <= 0) fireIon();
        }
        let timeSinceScore = Date.now() - lastScoreTime;
        if (timeSinceScore > CONFIG.multiplierResetTime && scoreMultiplier > 1) {
            scoreMultiplier = 1;
            updateHUD();
        }
        let pct = Math.max(0, 100 - (timeSinceScore / CONFIG.multiplierResetTime * 100));
        elMultBar.style.width = pct + "%";
        
        // --- PLAYER PHYSICS ---
        if (boostTimer > 0) {
            let phase = CONFIG.fireDuration - boostTimer;
            if (phase < 100) {
                player.vx = Math.cos(player.angle) * CONFIG.maxVelocity;
                player.vy = Math.sin(player.angle) * CONFIG.maxVelocity;
            } else if (phase < 300) {
                // Hold
            } else {
                let t = (phase - 300) / 100; 
                player.vx = player.vx * (1-t) + boostOriginalVx * t;
                player.vy = player.vy * (1-t) + boostOriginalVy * t;
                
                // Forward Fire
                fireTrails.push({
                    x: player.x + Math.cos(player.angle)*30 + (Math.random()-0.5)*10, 
                    y: player.y + Math.sin(player.angle)*30 + (Math.random()-0.5)*10,
                    life: CONFIG.fireTrailLife,
                    maxLife: CONFIG.fireTrailLife,
                    size: 15 + Math.random() * 15, 
                    angle: Math.random() * Math.PI * 2,
                    vx: Math.cos(player.angle) * 3, 
                    vy: Math.sin(player.angle) * 3
                });
            }
            
            boostTimer -= 16;
        } else {
            let diffX = getShortestAngleDiff(rawTiltBeta, baseTiltBeta); 
            let diffY = getShortestAngleDiff(rawTiltGamma, baseTiltGamma);

            if(diffX > CONFIG.maxTiltAngle) diffX = CONFIG.maxTiltAngle;
            if(diffX < -CONFIG.maxTiltAngle) diffX = -CONFIG.maxTiltAngle;
            if(diffY > CONFIG.maxTiltAngle) diffY = CONFIG.maxTiltAngle;
            if(diffY < -CONFIG.maxTiltAngle) diffY = -CONFIG.maxTiltAngle;

            let forceX = Math.sign(diffX) * Math.pow(Math.abs(diffX), CONFIG.inputExponent);
            let forceY = Math.sign(diffY) * Math.pow(Math.abs(diffY), CONFIG.inputExponent);

            let speed = Math.sqrt(player.vx*player.vx + player.vy*player.vy);
            let vxNorm = (speed > 0.1) ? player.vx / speed : 0;
            let vyNorm = (speed > 0.1) ? player.vy / speed : 0;
            let totalForce = Math.hypot(forceX, forceY);
            let fxNorm = (totalForce > 0) ? (forceX) / totalForce : 0;
            let fyNorm = (totalForce > 0) ? (forceY) / totalForce : 0;
            let dot = (vxNorm * (fxNorm * orientationSign)) + (vyNorm * (-fyNorm * orientationSign));
            let turnFactor = 1 - Math.abs(dot); 
            let dynamicAccel = CONFIG.acceleration * (1 + (turnFactor * CONFIG.turnBoost));

            player.vx += forceX * dynamicAccel * orientationSign; 
            player.vy -= forceY * dynamicAccel * orientationSign; 

            player.vx *= CONFIG.friction;
            player.vy *= CONFIG.friction;

            if (speed > CONFIG.maxVelocity) {
                let ratio = CONFIG.maxVelocity / speed;
                player.vx *= ratio;
                player.vy *= ratio;
            }
        }
        
        player.x += player.vx;
        player.y += player.vy;
        
        if(player.x < 0) { player.x = 0; player.vx *= -0.5; }
        if(player.x > width) { player.x = width; player.vx *= -0.5; }
        if(player.y < 0) { player.y = 0; player.vy *= -0.5; }
        if(player.y > height) { player.y = height; player.vy *= -0.5; }

        if (Math.abs(player.vx) > 0.1 || Math.abs(player.vy) > 0.1) {
            player.angle = Math.atan2(player.vy, player.vx);
        }

        if (invincibilityTimer > 0) {
            invincibilityTimer -= 16;
            if (invincibilityTimer <= 1000 && starOsc) stopStarSound(); 
            if (invincibilityTimer <= 0) {
                invincibilityTimer = 0;
                stopStarSound();
            }
        }

        // --- ION BLASTS ---
        for (let i = ionBlasts.length - 1; i >= 0; i--) {
            let ion = ionBlasts[i];
            ion.x += ion.vx;
            ion.y += ion.vy;
            ion.radius += CONFIG.ionGrowth;
            if (ion.radius > ion.maxRadius) { ionBlasts.splice(i, 1); continue; }
            for (let j = enemies.length - 1; j >= 0; j--) {
                let e = enemies[j];
                if (Math.hypot(ion.x - e.x, ion.y - e.y) < ion.radius + e.radius) {
                    enemies.splice(j, 1); scorePoints(10); createExplosion(e.x, e.y, '#00ffff');
                }
            }
        }

        // --- FIRE TRAILS ---
        for (let i = fireTrails.length - 1; i >= 0; i--) {
            let f = fireTrails[i];
            f.life -= 16;
            f.x += f.vx; f.y += f.vy;
            if (f.life <= 0) { fireTrails.splice(i, 1); continue; }
            for (let j = enemies.length - 1; j >= 0; j--) {
                let e = enemies[j];
                if (Math.hypot(f.x - e.x, f.y - e.y) < (f.size * 0.8) + e.radius) {
                    enemies.splice(j, 1); scorePoints(10); createExplosion(e.x, e.y, '#e67e22');
                }
            }
        }

        // --- BLACK HOLE ---
        for (let i = blackHoles.length - 1; i >= 0; i--) {
            let bh = blackHoles[i];
            bh.angle += 0.2; 
            if (bh.delay > 0) { bh.delay -= 16; continue; }
            bh.life -= 16;
            if (bh.life <= 0) { blackHoles.splice(i, 1); continue; }

            for (let j = enemies.length - 1; j >= 0; j--) {
                let e = enemies[j];
                let dx = bh.x - e.x;
                let dy = bh.y - e.y;
                let distSq = dx*dx + dy*dy;
                if (Math.sqrt(distSq) < 20) { 
                    enemies.splice(j, 1); scorePoints(10); playSound('suck'); createExplosion(bh.x, bh.y, '#8e44ad', 5);
                } else {
                    let f = (CONFIG.blackHoleForce * 2.0 * 1500) / Math.max(distSq, 100);
                    e.x += (dx / Math.sqrt(distSq)) * f;
                    e.y += (dy / Math.sqrt(distSq)) * f;
                }
            }

            for (let j = diamonds.length - 1; j >= 0; j--) {
                let d = diamonds[j];
                let dx = bh.x - d.x;
                let dy = bh.y - d.y;
                let distSq = dx*dx + dy*dy;
                if (distSq < 400) {
                    diamonds.splice(j, 1); scorePoints(1); increaseMultiplier(); playSound('suck');
                } else {
                    let f = (CONFIG.blackHoleForce * 1000) / Math.max(distSq, 100);
                    d.x += (dx / Math.sqrt(distSq)) * f;
                    d.y += (dy / Math.sqrt(distSq)) * f;
                }
            }
            
            let pdx = bh.x - player.x;
            let pdy = bh.y - player.y;
            let pDistSq = pdx*pdx + pdy*pdy;
            let pDist = Math.sqrt(pDistSq);
            let pf = (CONFIG.blackHoleForce * 0.9 * 300) / Math.max(pDistSq, 100); 
            player.vx += (pdx / pDist) * pf;
            player.vy += (pdy / pDist) * pf;
        }

        // --- COLLISIONS ---
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            
            if (invincibilityTimer <= 0) {
                let dx = player.x - e.x;
                let dy = player.y - e.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                e.vx = (dx / dist) * e.speed;
                e.vy = (dy / dist) * e.speed;
            } else {
                e.vx *= 0.95; e.vy *= 0.95; 
            }
            
            e.x += e.vx;
            e.y += e.vy;
            
            let hitDist = (shieldActive || invincibilityTimer > 0) ? CONFIG.shieldRadius : (player.size * CONFIG.hitboxRatio);
            let pDist = Math.hypot(player.x - e.x, player.y - e.y);

            if (pDist < hitDist + (e.radius * CONFIG.enemyHitboxRatio)) {
                if (invincibilityTimer > 0) {
                    enemies.splice(i, 1);
                    scorePoints(10); 
                    createExplosion(e.x, e.y, '#f1c40f');
                    playSound('crash');
                } else if (shieldActive) {
                    shieldActive = false;
                    createExplosion(player.x, player.y, '#3498db');
                    playSound('crash');
                    destroyEnemiesInRange(150);
                } else {
                    killPlayer();
                }
            }
        }

        for (let i = diamonds.length - 1; i >= 0; i--) {
            let d = diamonds[i];
            checkMagnet(d); 
            
            if (d.isProjectile) {
                 d.vx *= 0.97; d.vy *= 0.97; 
                 d.projectileTimer--; 
                 let speed = Math.hypot(d.vx, d.vy);
                 if(speed < 4.0) d.isProjectile = false;
                 else {
                     for (let j = enemies.length - 1; j >= 0; j--) {
                        let e = enemies[j];
                        if (Math.hypot(d.x - e.x, d.y - e.y) < 120) { 
                            enemies.splice(j, 1); scorePoints(10); createExplosion(e.x, e.y, '#f1c40f');
                        }
                     }
                 }
            }

            d.x += d.vx; d.y += d.vy;
            if(d.x < 0 || d.x > width) d.vx *= -1;
            if(d.y < 0 || d.y > height) d.vy *= -1;

            if (!d.isProjectile || d.projectileTimer <= 0) {
                let dist = Math.hypot(player.x - d.x, player.y - d.y);
                if (dist < player.size + CONFIG.diamondHitbox) {
                    scorePoints(1); 
                    increaseMultiplier(); 
                    playSound('coin');
                    diamonds.splice(i, 1);
                }
            }
        }

        for (let i = powerups.length - 1; i >= 0; i--) {
            let p = powerups[i];
            checkMagnet(p); 
            let dist = Math.hypot(player.x - p.x, player.y - p.y);
            if (dist < player.size + p.radius) {
                playSound('powerup');
                if(p.type === 'SHIELD') shieldActive = true;
                if(p.type === 'STAR') {
                    invincibilityTimer = CONFIG.invincibilityTime;
                    startStarSound(); 
                }
                if(p.type === 'HOLE') spawnBlackHole(p.x, p.y);
                if(p.type === 'FIRE') activateFireBooster();
                if(p.type === 'ION') triggerIonBlast();
                if(p.type === 'DIAMOND_BOMB') activateDiamondBomb();
                powerups.splice(i, 1);
            }
        }
        
        updateParticles();
        bgParticles.forEach(p => {
            p.y += p.speed;
            if(p.y > height) p.y = -50;
        });
    }

    function destroyEnemiesInRange(range) {
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            if (Math.hypot(player.x - e.x, player.y - e.y) < range) {
                enemies.splice(i, 1);
                scorePoints(10); 
                createExplosion(e.x, e.y, '#e74c3c');
            }
        }
    }

    function killPlayer() {
        state = 'DYING';
        lives--;
        scoreMultiplier = 1; 
        combo = 1;
        stopStarSound();
        updateHUD();
        createExplosion(player.x, player.y, '#ecf0f1', 50);
        playSound('crash');
        
        setTimeout(() => {
            if (lives > 0) {
                startCountdownSequence();
            } else {
                state = 'GAMEOVER';
                document.getElementById('final-score').innerText = "Final Score: " + score;
                uiGameOver.style.display = 'block';
            }
        }, 2000);
    }

    function createExplosion(x, y, color, count = 15) {
        for(let k=0; k<count; k++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0,
                color: color
            });
        }
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.02; 
            if(p.life <= 0) particles.splice(i, 1);
        }
    }

    function updateHUD() {
        elScore.innerText = "SCORE: " + score;
        elCombo.innerText = scoreMultiplier + "x";
        elMultContainer.style.display = 'block'; 
        
        let hearts = "";
        for(let i=0; i<lives; i++) hearts += "❤";
        elLives.innerText = hearts;
    }

    function draw() {
        let grd = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width);
        grd.addColorStop(0, '#145a14'); 
        grd.addColorStop(1, '#051e11'); 
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, width, height);
        
        ctx.strokeStyle = 'rgba(127, 255, 0, 0.15)';
        ctx.lineWidth = 2;
        const gridSize = 80;
        const offsetX = -(player.x * 0.15) % gridSize;
        const offsetY = -(player.y * 0.15) % gridSize;

        ctx.beginPath();
        for (let x = offsetX; x < width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
        for (let y = offsetY; y < height; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
        ctx.stroke();

        ctx.fillStyle = 'rgba(127, 255, 0, 0.1)';
        bgParticles.forEach(p => {
            ctx.beginPath();
            if(p.type === 'square') ctx.fillRect(p.x, p.y, p.size, p.size);
            else {
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x + p.size, p.y + p.size);
                ctx.lineTo(p.x - p.size, p.y + p.size);
                ctx.fill();
            }
        });

        fireTrails.forEach(f => {
            let alpha = f.life / CONFIG.fireTrailLife;
            if (alpha > 0.6) ctx.fillStyle = `rgba(230, 126, 34, ${alpha})`;
            else if (alpha > 0.3) ctx.fillStyle = `rgba(241, 196, 15, ${alpha})`;
            else ctx.fillStyle = `rgba(128, 128, 128, ${alpha})`;

            ctx.save();
            ctx.translate(f.x, f.y);
            ctx.rotate(f.angle + (Date.now()/200)); 
            let oscSize = f.size * (0.8 + Math.sin(Date.now()/50)*0.2); 
            ctx.beginPath();
            ctx.arc(0, 0, oscSize/2, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        });

        blackHoles.forEach(bh => {
            if (bh.delay > 0) {
                let progress = 1 - (bh.delay / CONFIG.blackHoleDelay);
                ctx.strokeStyle = `rgba(142, 68, 173, ${progress})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(bh.x, bh.y, 5 + (progress * 15), 0, Math.PI*2);
                ctx.stroke();
                ctx.fillStyle = `rgba(142, 68, 173, ${progress * 0.5})`;
                ctx.fill();
            } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                ctx.beginPath();
                ctx.arc(bh.x, bh.y, 15, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = '#9b59b6';
                ctx.lineWidth = 2;
                for(let i=0; i<5; i++) {
                    let angleOffset = (Math.PI * 2 / 5) * i + bh.angle;
                    ctx.beginPath();
                    for(let r=5; r<30; r+=2) {
                        let a = angleOffset + (r * 0.2); 
                        let px = bh.x + Math.cos(a) * r;
                        let py = bh.y + Math.sin(a) * r;
                        if (r===5) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
            }
        });

        ionBlasts.forEach(ion => {
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(ion.x, ion.y, ion.radius, 0, Math.PI*2);
            ctx.stroke();
            ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
            ctx.fill();
        });

        diamonds.forEach(d => {
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.moveTo(d.x, d.y - d.radius);
            ctx.lineTo(d.x + d.radius, d.y);
            ctx.lineTo(d.x, d.y + d.radius);
            ctx.lineTo(d.x - d.radius, d.y);
            ctx.fill();
            ctx.strokeStyle = 'white'; ctx.lineWidth = 1.5; ctx.stroke();
            if(Math.random() < 0.05) {
                ctx.fillStyle = 'white';
                ctx.fillRect(d.x - 2, d.y - 2, 4, 4);
            }
        });

        powerups.forEach(p => {
            ctx.beginPath();
            if (p.type === 'DIAMOND_BOMB') {
                 ctx.fillStyle = '#e67e22'; 
                 ctx.moveTo(p.x, p.y - p.radius);
                 ctx.lineTo(p.x + p.radius, p.y);
                 ctx.lineTo(p.x, p.y + p.radius);
                 ctx.lineTo(p.x - p.radius, p.y);
                 ctx.fill();
                 ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
            } else {
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2);
                if(p.type === 'SHIELD') {
                    ctx.fillStyle = '#3498db';
                    ctx.fill(); ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.stroke();
                    ctx.fillStyle = 'white'; ctx.font = '8px Arial'; ctx.fillText("S", p.x-2, p.y+3);
                } else if (p.type === 'STAR') {
                    ctx.fillStyle = '#f39c12';
                    ctx.fill(); ctx.fillStyle = 'white'; ctx.font = '8px Arial'; ctx.fillText("★", p.x-3, p.y+3);
                } else if (p.type === 'HOLE') {
                    ctx.fillStyle = '#2c3e50'; ctx.fill(); ctx.strokeStyle = '#8e44ad'; ctx.lineWidth = 3; ctx.stroke();
                } else if (p.type === 'FIRE') {
                    ctx.fillStyle = '#e67e22'; ctx.fill(); ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 2; ctx.stroke();
                } else if (p.type === 'ION') {
                    ctx.fillStyle = '#00ffff'; ctx.fill(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                }
            }
        });

        enemies.forEach(e => {
            ctx.globalAlpha = (e.mode === 'FORMATION' && formationStep < 2) ? 0.5 : 1.0;
            ctx.fillStyle = (e.mode === 'FORMATION') ? '#fff' : '#e74c3c'; 
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2);
            ctx.fill();
            ctx.strokeStyle = 'white'; ctx.lineWidth = 1.5; ctx.stroke();
            ctx.globalAlpha = 1.0;
        });

        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        });

        if (state === 'PLAYING' || state === 'COUNTDOWN') {
            ctx.save();
            ctx.translate(player.x, player.y);
            
            if (shieldActive) {
                ctx.strokeStyle = '#3498db'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(0,0, 20, 0, Math.PI*2); ctx.stroke();
            }
            if (invincibilityTimer > 0) {
                 ctx.save();
                 ctx.rotate(Date.now()/200); 
                 ctx.beginPath();
                 const spikes = 8;
                 const outer = 26; 
                 const inner = 17;
                 for(let i=0; i<spikes*2; i++) {
                     const r = (i%2===0) ? outer : inner;
                     const a = (Math.PI * i / spikes);
                     ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
                 }
                 ctx.closePath();
                 ctx.strokeStyle = '#f1c40f';
                 ctx.lineWidth = 4;
                 ctx.stroke();
                 ctx.restore();
            }

            ctx.rotate(player.angle);
            ctx.fillStyle = (invincibilityTimer > 0) ? '#f1c40f' : '#ecf0f1';
            ctx.beginPath();
            ctx.moveTo(player.size, 0);
            ctx.lineTo(-player.size, player.size);
            ctx.lineTo(-player.size * 0.5, 0);
            ctx.lineTo(-player.size, -player.size);
            ctx.fill();
            ctx.restore();
        }
    }

    function gameLoop() {
        requestAnimationFrame(gameLoop);
        if(state === 'PLAYING') { update(); draw(); } else if (state === 'DYING') { updateParticles(); draw(); } else if (state === 'COUNTDOWN' || state === 'PAUSED' || state === 'GAMEOVER' || state === 'SPLASH' || state === 'MENU') { draw(); }
    }
    
    requestAnimationFrame(gameLoop);

</script>
</body>
</html>
