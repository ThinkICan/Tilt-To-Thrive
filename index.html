<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tilt Survival: Vortex</title>
    <style>
        body { margin: 0; overflow: hidden; background: #2c3e50; font-family: -apple-system, BlinkMacSystemFont, sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
        
        h1 { font-size: 40px; margin: 0 0 10px 0; color: #ecf0f1; text-shadow: 2px 2px 0px #2c3e50; }
        h2 { font-size: 80px; color: #f1c40f; margin: 0; text-shadow: 4px 4px 0px #000; display: none; }
        p { font-size: 16px; color: #bdc3c7; margin-bottom: 20px; }
        
        #hud-top { position: absolute; top: 10px; left: 15px; right: 15px; display: flex; justify-content: space-between; pointer-events: none; }
        .hud-text { font-size: 20px; font-weight: bold; color: #ecf0f1; font-family: monospace; }
        #combo-text { color: #2ecc71; font-size: 16px; display: none;}

        button { pointer-events: auto; padding: 15px 40px; font-size: 24px; background: #3498db; color: white; border: none; border-radius: 50px; cursor: pointer; box-shadow: 0 6px 0 #2980b9; transition: transform 0.1s, box-shadow 0.1s; font-weight: bold; }
        button:active { transform: translateY(4px); box-shadow: 0 2px 0 #2980b9; }
        button.red { background: #e74c3c; box-shadow: 0 6px 0 #c0392b; }
        button.red:active { box-shadow: 0 2px 0 #c0392b; }

        /* Screens */
        #start-screen, #game-over, #pause-screen { pointer-events: auto; background: rgba(44, 62, 80, 0.95); padding: 30px; border-radius: 20px; border: 2px solid #34495e; }
        #pause-screen { display: none; }
        #rotate-msg { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #2c3e50; z-index: 999; color: white; flex-direction: column; justify-content: center; align-items: center; }
    </style>
</head>
<body>

    <div id="rotate-msg">
        <h1>↻</h1>
        <p>Please rotate to Landscape</p>
    </div>

    <div id="hud-top">
        <div style="text-align:left;">
            <div id="score-display" class="hud-text">SCORE: 0</div>
            <div id="combo-display" class="hud-text" style="color:#2ecc71; font-size:14px; opacity:0;">x1 COMBO</div>
        </div>
        <div id="lives-display" class="hud-text">❤❤❤</div>
    </div>
    
    <div id="ui-layer">
        <h2 id="countdown-text">3</h2>

        <div id="start-screen">
            <h1>Tilt Survival</h1>
            <p>• Tilt to Accelerate<br>• Tap to Pause<br>• Grab the Black Hole!</p>
            <button id="start-btn">TAP TO START</button>
            <p style="font-size: 12px; margin-top: 15px; color: #7f8c8d;">(Turn sound on!)</p>
        </div>

        <div id="pause-screen">
            <h1>PAUSED</h1>
            <p>Take a breath.</p>
            <button id="resume-btn">RESUME</button>
        </div>
        
        <div id="game-over" style="display: none;">
            <h1 style="color: #e74c3c;">CRASHED!</h1>
            <p id="final-score">Score: 0</p>
            <button class="red" id="retry-btn">TRY AGAIN</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    // --- CONFIG ---
    const CONFIG = {
        friction: 0.95,         
        acceleration: 0.006,    
        inputExponent: 1.3,     
        maxVelocity: 8.0,       // LOWERED to 8.0 per request
        
        enemyBaseSpeed: 1.5,
        hitboxRatio: 0.55,
        diamondHitbox: 12,      
        invincibilityTime: 5000,
        blackHoleDuration: 10000,
        blackHoleDelay: 2000,   // 2 second warmup
        blackHoleForce: 0.5     
    };

    // --- AUDIO ENGINE ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let starOsc = null; 
    let starGain = null;

    function unlockAudio() {
        if (audioCtx.state === 'suspended') { audioCtx.resume(); }
        const buffer = audioCtx.createBuffer(1, 1, 22050); 
        const source = audioCtx.createBufferSource(); 
        source.buffer = buffer; 
        source.connect(audioCtx.destination); 
        source.start(0); 
    }

    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;

        if (type === 'beep') { 
            osc.type = 'square'; osc.frequency.setValueAtTime(440, now); osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.1);
            gain.gain.setValueAtTime(0.1, now); osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'go') { 
            osc.type = 'square'; osc.frequency.setValueAtTime(880, now); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
            osc.start(now); osc.stop(now + 0.4);
        } else if (type === 'coin') { 
            osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.linearRampToValueAtTime(1800, now + 0.1);
            gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'crash') { 
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.5);
            gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5); osc.start(now); osc.stop(now + 0.5);
        } else if (type === 'powerup') { 
            osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); osc.frequency.linearRampToValueAtTime(800, now + 0.3);
            gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3);
        } else if (type === 'powerdown') { 
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(100, now + 0.5);
            gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5);
        } else if (type === 'suck') { 
            osc.type = 'sine'; osc.frequency.setValueAtTime(50, now); osc.frequency.linearRampToValueAtTime(10, now + 0.1);
            gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.1); osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'charge') { // Black hole charging
             osc.type = 'sine'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(500, now + 1.0);
             gain.gain.setValueAtTime(0.0, now); gain.gain.linearRampToValueAtTime(0.2, now+0.5); gain.gain.linearRampToValueAtTime(0, now+1.0);
             osc.start(now); osc.stop(now+1.0);
        }
    }

    function startStarSound() {
        if (starOsc) return; 
        starOsc = audioCtx.createOscillator();
        starGain = audioCtx.createGain();
        starOsc.type = 'square';
        starOsc.frequency.setValueAtTime(150, audioCtx.currentTime);
        
        const lfo = audioCtx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 10; 
        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = 500;
        lfo.connect(lfoGain);
        lfoGain.connect(starOsc.frequency);
        lfo.start();

        starOsc.connect(starGain);
        starGain.connect(audioCtx.destination);
        starGain.gain.value = 0.05;
        starOsc.start();
    }

    function stopStarSound() {
        if (starOsc) {
            try { starOsc.stop(); playSound('powerdown'); } catch(e) {}
            starOsc = null;
            starGain = null;
        }
    }

    // --- SETUP ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const uiStart = document.getElementById('start-screen');
    const uiPause = document.getElementById('pause-screen');
    const uiGameOver = document.getElementById('game-over');
    const uiCountdown = document.getElementById('countdown-text');
    const elScore = document.getElementById('score-display');
    const elCombo = document.getElementById('combo-display');
    const elLives = document.getElementById('lives-display');
    const rotateMsg = document.getElementById('rotate-msg');

    let state = 'MENU'; 
    let width, height;
    let lives = 3;
    let score = 0;
    let combo = 1;
    let orientationSign = 1;

    let rawTiltBeta = 0, rawTiltGamma = 0; 
    let baseTiltBeta = 0, baseTiltGamma = 0; 

    let player = { x: 0, y: 0, vx: 0, vy: 0, size: 10.5, angle: 0 };
    let enemies = [];
    let diamonds = [];
    let powerups = [];
    let blackHoles = []; 
    let particles = [];
    let bgParticles = []; 
    let shieldActive = false;
    let invincibilityTimer = 0;

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        
        let angle = 0;
        if (screen.orientation && screen.orientation.angle) {
            angle = screen.orientation.angle;
        } else if (window.orientation) {
            angle = window.orientation;
        }

        if (height > width) {
            rotateMsg.style.display = 'flex';
            if(state === 'PLAYING') pauseGame();
        } else {
            rotateMsg.style.display = 'none';
            if (angle === -90 || angle === 270) {
                orientationSign = -1;
            } else {
                orientationSign = 1;
            }
        }
    }
    window.addEventListener('resize', resize);
    window.addEventListener('orientationchange', () => { setTimeout(resize, 200); });
    resize();

    // Background Init
    for(let i=0; i<20; i++) {
        bgParticles.push({
            x: Math.random() * window.innerWidth,
            y: Math.random() * window.innerHeight,
            size: Math.random() * 20 + 5,
            speed: Math.random() * 0.5 + 0.1,
            type: Math.random() < 0.5 ? 'square' : 'triangle'
        });
    }

    // --- INPUTS ---
    document.getElementById('start-btn').addEventListener('click', (e) => {
        e.stopPropagation(); 
        unlockAudio(); 
        initPermsAndStart();
    });
    
    document.getElementById('retry-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        unlockAudio();
        startCountdownSequence();
    });

    document.getElementById('resume-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        resumeGame();
    });

    // Tap to Pause
    window.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') return;
        if (state === 'PLAYING') {
            pauseGame();
        }
    });

    function pauseGame() {
        state = 'PAUSED';
        uiPause.style.display = 'block';
        if(starOsc) starOsc.disconnect(); 
    }

    function resumeGame() {
        state = 'PLAYING';
        uiPause.style.display = 'none';
        if(invincibilityTimer > 0 && starOsc) starOsc.connect(starGain); 
        loop();
    }

    async function initPermsAndStart() {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const perm = await DeviceOrientationEvent.requestPermission();
                if (perm === 'granted') startCountdownSequence();
                else alert('Permission denied');
            } catch (e) { console.error(e); }
        } else {
            startCountdownSequence();
        }
    }

    window.addEventListener('deviceorientation', (e) => {
        if(e.gamma !== null) rawTiltGamma = e.gamma; 
        if(e.beta !== null) rawTiltBeta = e.beta;
    });

    function startCountdownSequence() {
        uiStart.style.display = 'none';
        uiGameOver.style.display = 'none';
        uiPause.style.display = 'none';
        uiCountdown.style.display = 'block';
        
        enemies = []; 
        diamonds = []; 
        powerups = [];
        blackHoles = [];
        
        if(lives <= 0 || state === 'MENU') {
            lives = 3; score = 0; combo = 1;
        }
        
        player.x = width/2; player.y = height/2;
        player.vx = 0; player.vy = 0;
        shieldActive = false; invincibilityTimer = 0;
        stopStarSound();

        updateHUD();
        state = 'COUNTDOWN';
        
        let count = 3;
        uiCountdown.innerText = count;
        playSound('beep');
        
        let timer = setInterval(() => {
            count--;
            if (count > 0) {
                uiCountdown.innerText = count;
                playSound('beep');
            } else {
                clearInterval(timer);
                uiCountdown.innerText = "GO!";
                playSound('go');
                
                // CALIBRATION
                baseTiltGamma = rawTiltGamma;
                baseTiltBeta = rawTiltBeta;
                
                setTimeout(() => {
                    uiCountdown.style.display = 'none';
                    state = 'PLAYING';
                    spawnManager();
                    loop(); 
                }, 500);
            }
        }, 1000);
    }

    function spawnManager() {
        if (state !== 'PLAYING') return;
        if (Math.random() < 0.05 + (score * 0.0001)) spawnEnemy();
        if (Math.random() < 0.06) spawnDiamond(); 
        if (Math.random() < 0.016) spawnPowerup(); 
        setTimeout(spawnManager, 100); 
    }

    function spawnEnemy() {
        let ex, ey;
        let edge = Math.floor(Math.random() * 4); 
        if(edge === 0) { ex = Math.random() * width; ey = -20; }
        else if(edge === 1) { ex = width + 20; ey = Math.random() * height; }
        else if(edge === 2) { ex = Math.random() * width; ey = height + 20; }
        else { ex = -20; ey = Math.random() * height; }
        
        // --- SPEED SCALING REDUCED ---
        // Max Speed capped at 8.0
        // Slower ramp: score * 0.002 instead of 0.01
        let speed = Math.min(8.0, CONFIG.enemyBaseSpeed + (score * 0.002));
        
        enemies.push({ x: ex, y: ey, speed: speed, vx: 0, vy: 0, radius: 6 });
    }

    function spawnDiamond() {
        diamonds.push({ 
            x: Math.random() * (width-40) + 20, 
            y: Math.random() * (height-40) + 20, 
            radius: 7.5 
        });
    }

    function spawnPowerup() {
        let r = Math.random();
        let type = 'SHIELD';
        if (r < 0.33) type = 'STAR';
        else if (r < 0.66) type = 'HOLE'; 

        powerups.push({ 
            x: Math.random() * (width-40) + 20, 
            y: Math.random() * (height-40) + 20, 
            type: type,
            radius: 9 
        });
    }

    function spawnBlackHole(x, y) {
        playSound('charge');
        blackHoles.push({
            x: x,
            y: y,
            delay: CONFIG.blackHoleDelay, // Warmup
            life: CONFIG.blackHoleDuration, // Active time
            angle: 0 // For spiral animation
        });
    }

    function getShortestAngleDiff(current, target) {
        let diff = current - target;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return diff;
    }

    function update() {
        // --- PLAYER PHYSICS ---
        let diffX = getShortestAngleDiff(rawTiltBeta, baseTiltBeta); 
        let diffY = getShortestAngleDiff(rawTiltGamma, baseTiltGamma);

        let forceX = Math.sign(diffX) * Math.pow(Math.abs(diffX), CONFIG.inputExponent);
        let forceY = Math.sign(diffY) * Math.pow(Math.abs(diffY), CONFIG.inputExponent);

        player.vx += forceX * CONFIG.acceleration * orientationSign; 
        player.vy -= forceY * CONFIG.acceleration * orientationSign; 

        player.vx *= CONFIG.friction;
        player.vy *= CONFIG.friction;

        // Player Speed Cap
        let speed = Math.sqrt(player.vx*player.vx + player.vy*player.vy);
        if (speed > CONFIG.maxVelocity) {
            let ratio = CONFIG.maxVelocity / speed;
            player.vx *= ratio;
            player.vy *= ratio;
        }
        
        player.x += player.vx;
        player.y += player.vy;
        
        if(player.x < 0) { player.x = 0; player.vx *= -0.5; }
        if(player.x > width) { player.x = width; player.vx *= -0.5; }
        if(player.y < 0) { player.y = 0; player.vy *= -0.5; }
        if(player.y > height) { player.y = height; player.vy *= -0.5; }

        if (Math.abs(player.vx) > 0.1 || Math.abs(player.vy) > 0.1) {
            player.angle = Math.atan2(player.vy, player.vx);
        }

        if (invincibilityTimer > 0) {
            invincibilityTimer -= 16;
            if (invincibilityTimer <= 1000 && starOsc) stopStarSound(); 
            if (invincibilityTimer <= 0) {
                invincibilityTimer = 0;
                stopStarSound();
            }
        }

        // --- BLACK HOLE PHYSICS ---
        for (let i = blackHoles.length - 1; i >= 0; i--) {
            let bh = blackHoles[i];
            
            bh.angle += 0.2; // Spin

            // Charging phase?
            if (bh.delay > 0) {
                bh.delay -= 16;
                continue; // Do nothing else
            }

            bh.life -= 16;
            if (bh.life <= 0) {
                blackHoles.splice(i, 1);
                continue;
            }

            // Attract Enemies
            for (let j = enemies.length - 1; j >= 0; j--) {
                let e = enemies[j];
                let dx = bh.x - e.x;
                let dy = bh.y - e.y;
                let distSq = dx*dx + dy*dy;
                let dist = Math.sqrt(distSq);
                
                if (dist < 20) { // Sucked in
                    enemies.splice(j, 1);
                    score += 10; 
                    playSound('suck');
                    createExplosion(bh.x, bh.y, '#8e44ad', 5);
                } else {
                    let f = (CONFIG.blackHoleForce * 1000) / Math.max(distSq, 100);
                    e.x += (dx / dist) * f;
                    e.y += (dy / dist) * f;
                }
            }

            // Attract Diamonds
            for (let j = diamonds.length - 1; j >= 0; j--) {
                let d = diamonds[j];
                let dx = bh.x - d.x;
                let dy = bh.y - d.y;
                let distSq = dx*dx + dy*dy;
                if (distSq < 400) {
                    diamonds.splice(j, 1);
                    score += combo; 
                    playSound('suck');
                } else {
                    let dist = Math.sqrt(distSq);
                    let f = (CONFIG.blackHoleForce * 1000) / Math.max(distSq, 100);
                    d.x += (dx / dist) * f;
                    d.y += (dy / dist) * f;
                }
            }
            // Attract Player
            let pdx = bh.x - player.x;
            let pdy = bh.y - player.y;
            let pDistSq = pdx*pdx + pdy*pdy;
            let pDist = Math.sqrt(pDistSq);
            let pf = (CONFIG.blackHoleForce * 300) / Math.max(pDistSq, 100); 
            player.vx += (pdx / pDist) * pf;
            player.vy += (pdy / pDist) * pf;
        }

        // --- COLLISIONS ---
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            
            // AI Movement
            if (invincibilityTimer <= 0) {
                let dx = player.x - e.x;
                let dy = player.y - e.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                e.vx = (dx / dist) * e.speed;
                e.vy = (dy / dist) * e.speed;
            } else {
                e.vx *= 0.95; e.vy *= 0.95; // Drift
            }
            
            e.x += e.vx;
            e.y += e.vy;
            
            let pDist = Math.hypot(player.x - e.x, player.y - e.y);

            if (pDist < (player.size + e.radius) * CONFIG.hitboxRatio) {
                if (invincibilityTimer > 0) {
                    enemies.splice(i, 1);
                    score += 10; 
                    createExplosion(e.x, e.y, '#f1c40f');
                    playSound('crash');
                } else if (shieldActive) {
                    shieldActive = false;
                    createExplosion(player.x, player.y, '#3498db');
                    playSound('crash');
                    destroyEnemiesInRange(150);
                } else {
                    killPlayer();
                }
            }
        }

        for (let i = diamonds.length - 1; i >= 0; i--) {
            let d = diamonds[i];
            let dist = Math.hypot(player.x - d.x, player.y - d.y);
            if (dist < player.size + CONFIG.diamondHitbox) {
                score += combo;
                combo++;
                updateHUD();
                playSound('coin');
                diamonds.splice(i, 1);
            }
        }

        for (let i = powerups.length - 1; i >= 0; i--) {
            let p = powerups[i];
            let dist = Math.hypot(player.x - p.x, player.y - p.y);
            if (dist < player.size + p.radius) {
                playSound('powerup');
                if(p.type === 'SHIELD') shieldActive = true;
                if(p.type === 'STAR') {
                    invincibilityTimer = CONFIG.invincibilityTime;
                    startStarSound(); 
                }
                if(p.type === 'HOLE') {
                    spawnBlackHole(p.x, p.y);
                }
                powerups.splice(i, 1);
            }
        }
        
        updateParticles();
        bgParticles.forEach(p => {
            p.y += p.speed;
            if(p.y > height) p.y = -50;
        });
    }

    function destroyEnemiesInRange(range) {
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            if (Math.hypot(player.x - e.x, player.y - e.y) < range) {
                enemies.splice(i, 1);
                score += 10; 
                createExplosion(e.x, e.y, '#e74c3c');
            }
        }
    }

    function killPlayer() {
        state = 'DYING';
        lives--;
        combo = 1;
        stopStarSound();
        updateHUD();
        createExplosion(player.x, player.y, '#ecf0f1', 50);
        playSound('crash');
        
        setTimeout(() => {
            if (lives > 0) {
                startCountdownSequence();
            } else {
                state = 'GAMEOVER';
                document.getElementById('final-score').innerText = "Final Score: " + score;
                uiGameOver.style.display = 'block';
            }
        }, 2000);
    }

    function createExplosion(x, y, color, count = 15) {
        for(let k=0; k<count; k++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0,
                color: color
            });
        }
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.02; 
            if(p.life <= 0) particles.splice(i, 1);
        }
    }

    function updateHUD() {
        elScore.innerText = "SCORE: " + score;
        let hearts = "";
        for(let i=0; i<lives; i++) hearts += "❤";
        elLives.innerText = hearts;
        
        if(combo > 1) {
            elCombo.style.display = 'block';
            elCombo.style.opacity = 1;
            elCombo.innerText = "x" + combo + " COMBO";
        } else {
            elCombo.style.display = 'none';
        }
    }

    function draw() {
        // --- BACKGROUND ---
        ctx.fillStyle = '#2c3e50';
        ctx.fillRect(0, 0, width, height);
        
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 2;
        const gridSize = 80;
        const offsetX = -(player.x * 0.15) % gridSize;
        const offsetY = -(player.y * 0.15) % gridSize;

        ctx.beginPath();
        for (let x = offsetX; x < width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
        for (let y = offsetY; y < height; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
        ctx.stroke();

        ctx.fillStyle = 'rgba(255,255,255,0.05)';
        bgParticles.forEach(p => {
            ctx.beginPath();
            if(p.type === 'square') ctx.fillRect(p.x, p.y, p.size, p.size);
            else {
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x + p.size, p.y + p.size);
                ctx.lineTo(p.x - p.size, p.y + p.size);
                ctx.fill();
            }
        });

        // --- BLACK HOLES ---
        blackHoles.forEach(bh => {
            if (bh.delay > 0) {
                // CHARGING ANIMATION
                let progress = 1 - (bh.delay / CONFIG.blackHoleDelay);
                ctx.strokeStyle = `rgba(142, 68, 173, ${progress})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(bh.x, bh.y, 5 + (progress * 15), 0, Math.PI*2);
                ctx.stroke();
                
                ctx.fillStyle = `rgba(142, 68, 173, ${progress * 0.5})`;
                ctx.fill();
            } else {
                // ACTIVE VORTEX ANIMATION
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.beginPath();
                ctx.arc(bh.x, bh.y, 15, 0, Math.PI*2);
                ctx.fill();
                
                // Swirling Spiral
                ctx.strokeStyle = '#8e44ad';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for(let i=0; i<3; i++) {
                    let offset = (Math.PI*2/3) * i;
                    let r = 25;
                    let a = bh.angle + offset;
                    ctx.moveTo(bh.x + Math.cos(a)*r, bh.y + Math.sin(a)*r);
                    ctx.lineTo(bh.x, bh.y);
                }
                ctx.stroke();
            }
        });

        // --- ITEMS ---
        ctx.fillStyle = '#f1c40f';
        diamonds.forEach(d => {
            ctx.beginPath();
            ctx.moveTo(d.x, d.y - d.radius);
            ctx.lineTo(d.x + d.radius, d.y);
            ctx.lineTo(d.x, d.y + d.radius);
            ctx.lineTo(d.x - d.radius, d.y);
            ctx.fill();
        });

        powerups.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2);
            if(p.type === 'SHIELD') {
                ctx.fillStyle = '#3498db';
                ctx.fill(); ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = 'white'; ctx.font = '8px Arial'; ctx.fillText("S", p.x-2, p.y+3);
            } else if (p.type === 'STAR') {
                ctx.fillStyle = '#f39c12';
                ctx.fill(); ctx.fillStyle = 'white'; ctx.font = '8px Arial'; ctx.fillText("★", p.x-3, p.y+3);
            } else {
                // BLACK HOLE ORB
                ctx.fillStyle = '#2c3e50'; 
                ctx.fill();
                ctx.strokeStyle = '#8e44ad'; 
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        });

        // --- ENEMIES ---
        ctx.fillStyle = '#e74c3c';
        enemies.forEach(e => {
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2);
            ctx.fill();
        });

        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        });

        if (state === 'PLAYING' || state === 'COUNTDOWN') {
            ctx.save();
            ctx.translate(player.x, player.y);
            
            if (shieldActive) {
                ctx.strokeStyle = '#3498db'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(0,0, 18, 0, Math.PI*2); ctx.stroke();
            }
            if (invincibilityTimer > 0) {
                 if (Math.floor(Date.now() / 50) % 2 === 0) ctx.fillStyle = '#f1c40f';
                 else ctx.fillStyle = '#ecf0f1';
            } else {
                ctx.fillStyle = '#ecf0f1';
            }

            ctx.rotate(player.angle);
            ctx.beginPath();
            ctx.moveTo(player.size, 0);
            ctx.lineTo(-player.size, player.size);
            ctx.lineTo(-player.size * 0.5, 0);
            ctx.lineTo(-player.size, -player.size);
            ctx.fill();
            ctx.restore();
        }

        if(state === 'PLAYING') {
            requestAnimationFrame(draw);
            update();
        } else if (state === 'COUNTDOWN' || state === 'DYING') {
            requestAnimationFrame(draw);
            if (state === 'DYING') updateParticles();
        }
    }

    function loop() {
        if(state === 'PLAYING') {
            draw();
        }
    }
</script>
</body>
</html>
