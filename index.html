<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tilt Survival: Smart Landscape</title>
    <style>
        body { margin: 0; overflow: hidden; background: #2c3e50; font-family: -apple-system, BlinkMacSystemFont, sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
        
        h1 { font-size: 40px; margin: 0 0 10px 0; color: #ecf0f1; text-shadow: 2px 2px 0px #2c3e50; }
        h2 { font-size: 80px; color: #f1c40f; margin: 0; text-shadow: 4px 4px 0px #000; display: none; }
        p { font-size: 16px; color: #bdc3c7; margin-bottom: 20px; }
        
        #hud-top { position: absolute; top: 10px; left: 15px; right: 15px; display: flex; justify-content: space-between; pointer-events: none; }
        .hud-text { font-size: 20px; font-weight: bold; color: #ecf0f1; font-family: monospace; }
        #combo-text { color: #2ecc71; font-size: 16px; display: none;}

        button { pointer-events: auto; padding: 15px 40px; font-size: 24px; background: #3498db; color: white; border: none; border-radius: 50px; cursor: pointer; box-shadow: 0 6px 0 #2980b9; transition: transform 0.1s, box-shadow 0.1s; font-weight: bold; }
        button:active { transform: translateY(4px); box-shadow: 0 2px 0 #2980b9; }
        button.red { background: #e74c3c; box-shadow: 0 6px 0 #c0392b; }
        button.red:active { box-shadow: 0 2px 0 #c0392b; }

        #start-screen, #game-over { pointer-events: auto; background: rgba(44, 62, 80, 0.9); padding: 30px; border-radius: 20px; border: 2px solid #34495e; }
        #rotate-msg { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #2c3e50; z-index: 999; color: white; flex-direction: column; justify-content: center; align-items: center; }
    </style>
</head>
<body>

    <div id="rotate-msg">
        <h1>↻</h1>
        <p>Please rotate to Landscape</p>
    </div>

    <div id="hud-top">
        <div style="text-align:left;">
            <div id="score-display" class="hud-text">SCORE: 0</div>
            <div id="combo-display" class="hud-text" style="color:#2ecc71; font-size:14px; opacity:0;">x1 COMBO</div>
        </div>
        <div id="lives-display" class="hud-text">❤❤❤</div>
    </div>
    
    <div id="ui-layer">
        <h2 id="countdown-text">3</h2>

        <div id="start-screen">
            <h1>Tilt Survival</h1>
            <p>• Tilt to Accelerate<br>• Flat to Coast<br>• Collect Diamonds</p>
            <button id="start-btn">TAP TO START</button>
            <p style="font-size: 12px; margin-top: 15px; color: #7f8c8d;">(Turn sound on!)</p>
        </div>
        
        <div id="game-over" style="display: none;">
            <h1 style="color: #e74c3c;">CRASHED!</h1>
            <p id="final-score">Score: 0</p>
            <button class="red" id="retry-btn">TRY AGAIN</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    // --- CONFIG ---
    const CONFIG = {
        friction: 0.95,         
        acceleration: 0.006,    
        inputExponent: 1.6,     
        maxVelocity: 9.0,       
        
        enemyBaseSpeed: 1.5,
        hitboxRatio: 0.55, 
        invincibilityTime: 5000 
    };

    // --- AUDIO ENGINE ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let starOsc = null; // Oscillator for star powerup loop
    let starGain = null;

    function unlockAudio() {
        if (audioCtx.state === 'suspended') { audioCtx.resume(); }
        const buffer = audioCtx.createBuffer(1, 1, 22050); 
        const source = audioCtx.createBufferSource(); 
        source.buffer = buffer; 
        source.connect(audioCtx.destination); 
        source.start(0); 
    }

    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;

        if (type === 'beep') { 
            osc.type = 'square'; osc.frequency.setValueAtTime(440, now); osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.1);
            gain.gain.setValueAtTime(0.1, now); osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'go') { 
            osc.type = 'square'; osc.frequency.setValueAtTime(880, now); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
            osc.start(now); osc.stop(now + 0.4);
        } else if (type === 'coin') { 
            osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.linearRampToValueAtTime(1800, now + 0.1);
            gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'crash') { 
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.5);
            gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5); osc.start(now); osc.stop(now + 0.5);
        } else if (type === 'powerup') { 
            osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); osc.frequency.linearRampToValueAtTime(800, now + 0.3);
            gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3);
        } else if (type === 'powerdown') { // New sound for ending
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(100, now + 0.5);
            gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5);
        }
    }

    function startStarSound() {
        if (starOsc) return; // Already playing
        starOsc = audioCtx.createOscillator();
        starGain = audioCtx.createGain();
        starOsc.type = 'square';
        starOsc.frequency.setValueAtTime(150, audioCtx.currentTime);
        
        // LFO effect for pulsing sound
        const lfo = audioCtx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 10; // 10 Hz wobble
        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = 500;
        lfo.connect(lfoGain);
        lfoGain.connect(starOsc.frequency);
        lfo.start();

        starOsc.connect(starGain);
        starGain.connect(audioCtx.destination);
        starGain.gain.value = 0.05;
        starOsc.start();
    }

    function stopStarSound() {
        if (starOsc) {
            try {
                starOsc.stop();
                playSound('powerdown'); // Play power down sound
            } catch(e) {}
            starOsc = null;
            starGain = null;
        }
    }

    // --- SETUP ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const uiStart = document.getElementById('start-screen');
    const uiGameOver = document.getElementById('game-over');
    const uiCountdown = document.getElementById('countdown-text');
    const elScore = document.getElementById('score-display');
    const elCombo = document.getElementById('combo-display');
    const elLives = document.getElementById('lives-display');
    const rotateMsg = document.getElementById('rotate-msg');

    let state = 'MENU'; 
    let width, height;
    let lives = 3;
    let score = 0;
    let combo = 1;
    
    // Orientation Handling
    let orientationSign = 1; // 1 for Standard Landscape, -1 for Flipped

    let rawTiltBeta = 0, rawTiltGamma = 0; 
    let baseTiltBeta = 0, baseTiltGamma = 0; 

    let player = { x: 0, y: 0, vx: 0, vy: 0, size: 10.5, angle: 0 };
    let enemies = [];
    let diamonds = [];
    let powerups = [];
    let particles = [];
    let shieldActive = false;
    let invincibilityTimer = 0;

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        
        // Check Orientation Angle
        let angle = 0;
        if (screen.orientation && screen.orientation.angle) {
            angle = screen.orientation.angle;
        } else if (window.orientation) {
            angle = window.orientation;
        }

        // Check if portrait
        if (height > width) {
            rotateMsg.style.display = 'flex';
            if(state === 'PLAYING') state = 'PAUSED';
        } else {
            rotateMsg.style.display = 'none';
            if(state === 'PAUSED') state = 'PLAYING';
            
            // DETECT FLIPPED LANDSCAPE
            // Usually 90 is standard landscape (home button right)
            // -90 or 270 is flipped (home button left)
            if (angle === -90 || angle === 270) {
                orientationSign = -1;
            } else {
                orientationSign = 1;
            }
        }
    }
    window.addEventListener('resize', resize);
    window.addEventListener('orientationchange', () => { setTimeout(resize, 200); });
    resize();

    document.getElementById('start-btn').addEventListener('click', (e) => {
        unlockAudio(); 
        initPermsAndStart();
    });
    
    document.getElementById('retry-btn').addEventListener('click', () => {
        unlockAudio();
        startCountdownSequence();
    });

    async function initPermsAndStart() {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const perm = await DeviceOrientationEvent.requestPermission();
                if (perm === 'granted') startCountdownSequence();
                else alert('Permission denied');
            } catch (e) { console.error(e); }
        } else {
            startCountdownSequence();
        }
    }

    window.addEventListener('deviceorientation', (e) => {
        if(e.gamma !== null) rawTiltGamma = e.gamma; 
        if(e.beta !== null) rawTiltBeta = e.beta;
    });

    function startCountdownSequence() {
        uiStart.style.display = 'none';
        uiGameOver.style.display = 'none';
        uiCountdown.style.display = 'block';
        
        // CLEAR BOARD
        enemies = []; 
        diamonds = []; 
        powerups = [];
        
        if(lives <= 0 || state === 'MENU') {
            lives = 3; score = 0; combo = 1;
        }
        
        player.x = width/2; player.y = height/2;
        player.vx = 0; player.vy = 0;
        shieldActive = false; invincibilityTimer = 0;
        stopStarSound();

        updateHUD();
        state = 'COUNTDOWN';
        
        let count = 3;
        uiCountdown.innerText = count;
        playSound('beep');
        
        let timer = setInterval(() => {
            count--;
            if (count > 0) {
                uiCountdown.innerText = count;
                playSound('beep');
            } else {
                clearInterval(timer);
                uiCountdown.innerText = "GO!";
                playSound('go');
                
                // CALIBRATION
                baseTiltGamma = rawTiltGamma;
                baseTiltBeta = rawTiltBeta;
                
                setTimeout(() => {
                    uiCountdown.style.display = 'none';
                    state = 'PLAYING';
                    spawnManager();
                }, 500);
            }
        }, 1000);
    }

    function spawnManager() {
        if (state !== 'PLAYING') return;
        if (Math.random() < 0.05 + (score * 0.0001)) spawnEnemy();
        if (Math.random() < 0.02) spawnDiamond();
        if (Math.random() < 0.008) spawnPowerup(); // Increased frequency (was 0.002)
        setTimeout(spawnManager, 100); 
    }

    function spawnEnemy() {
        let ex, ey;
        let edge = Math.floor(Math.random() * 4); 
        if(edge === 0) { ex = Math.random() * width; ey = -20; }
        else if(edge === 1) { ex = width + 20; ey = Math.random() * height; }
        else if(edge === 2) { ex = Math.random() * width; ey = height + 20; }
        else { ex = -20; ey = Math.random() * height; }
        
        let speed = CONFIG.enemyBaseSpeed + (score * 0.01);
        enemies.push({ x: ex, y: ey, speed: speed, vx: 0, vy: 0, radius: 6 });
    }

    function spawnDiamond() {
        diamonds.push({ 
            x: Math.random() * (width-40) + 20, 
            y: Math.random() * (height-40) + 20, 
            radius: 7.5 
        });
    }

    function spawnPowerup() {
        let type = Math.random() < 0.5 ? 'SHIELD' : 'STAR';
        powerups.push({ 
            x: Math.random() * (width-40) + 20, 
            y: Math.random() * (height-40) + 20, 
            type: type,
            radius: 9 
        });
    }

    function getShortestAngleDiff(current, target) {
        let diff = current - target;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return diff;
    }

    function update() {
        if (state !== 'PLAYING') {
             if (state === 'DYING') updateParticles();
             return;
        }

        let diffX = getShortestAngleDiff(rawTiltBeta, baseTiltBeta); 
        let diffY = getShortestAngleDiff(rawTiltGamma, baseTiltGamma);

        let forceX = Math.sign(diffX) * Math.pow(Math.abs(diffX), CONFIG.inputExponent);
        let forceY = Math.sign(diffY) * Math.pow(Math.abs(diffY), CONFIG.inputExponent);

        // --- SMART AXIS MAPPING ---
        // We multiply by orientationSign to handle Flipped Landscape
        
        // X Axis (Left/Right)
        player.vx += forceX * CONFIG.acceleration * orientationSign; 
        
        // Y Axis (Up/Down)
        player.vy += forceY * CONFIG.acceleration * orientationSign; 

        // Friction
        player.vx *= CONFIG.friction;
        player.vy *= CONFIG.friction;

        // Velocity Cap
        let speed = Math.sqrt(player.vx*player.vx + player.vy*player.vy);
        if (speed > CONFIG.maxVelocity) {
            let ratio = CONFIG.maxVelocity / speed;
            player.vx *= ratio;
            player.vy *= ratio;
        }
        
        player.x += player.vx;
        player.y += player.vy;
        
        if(player.x < 0) { player.x = 0; player.vx *= -0.5; }
        if(player.x > width) { player.x = width; player.vx *= -0.5; }
        if(player.y < 0) { player.y = 0; player.vy *= -0.5; }
        if(player.y > height) { player.y = height; player.vy *= -0.5; }

        if (Math.abs(player.vx) > 0.1 || Math.abs(player.vy) > 0.1) {
            player.angle = Math.atan2(player.vy, player.vx);
        }

        // Invincibility Logic
        if (invincibilityTimer > 0) {
            invincibilityTimer -= 16;
            if (invincibilityTimer <= 1000 && starOsc) {
                stopStarSound(); // Cut sound 1s before end to warn user
            }
            if (invincibilityTimer <= 0) {
                invincibilityTimer = 0;
                stopStarSound();
            }
        }

        // --- COLLISIONS ---
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            let dx = player.x - e.x;
            let dy = player.y - e.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            
            e.vx = (dx / dist) * e.speed;
            e.vy = (dy / dist) * e.speed;
            e.x += e.vx;
            e.y += e.vy;
            
            if (dist < (player.size + e.radius) * CONFIG.hitboxRatio) {
                if (invincibilityTimer > 0) {
                    enemies.splice(i, 1);
                    score += 5;
                    createExplosion(e.x, e.y, '#f1c40f');
                    playSound('crash');
                } else if (shieldActive) {
                    shieldActive = false;
                    createExplosion(player.x, player.y, '#3498db');
                    playSound('crash');
                    destroyEnemiesInRange(150);
                } else {
                    killPlayer();
                }
            }
        }

        for (let i = diamonds.length - 1; i >= 0; i--) {
            let d = diamonds[i];
            let dist = Math.hypot(player.x - d.x, player.y - d.y);
            if (dist < player.size + d.radius) {
                score += combo;
                combo++;
                updateHUD();
                playSound('coin');
                diamonds.splice(i, 1);
            }
        }

        for (let i = powerups.length - 1; i >= 0; i--) {
            let p = powerups[i];
            let dist = Math.hypot(player.x - p.x, player.y - p.y);
            if (dist < player.size + p.radius) {
                playSound('powerup');
                if(p.type === 'SHIELD') shieldActive = true;
                if(p.type === 'STAR') {
                    invincibilityTimer = CONFIG.invincibilityTime;
                    startStarSound(); // Start loop
                }
                powerups.splice(i, 1);
            }
        }
        
        updateParticles();
    }

    function destroyEnemiesInRange(range) {
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            if (Math.hypot(player.x - e.x, player.y - e.y) < range) {
                enemies.splice(i, 1);
                createExplosion(e.x, e.y, '#e74c3c');
            }
        }
    }

    function killPlayer() {
        state = 'DYING';
        lives--;
        combo = 1;
        stopStarSound();
        updateHUD();
        createExplosion(player.x, player.y, '#ecf0f1', 50);
        playSound('crash');
        
        setTimeout(() => {
            if (lives > 0) {
                startCountdownSequence();
            } else {
                state = 'GAMEOVER';
                document.getElementById('final-score').innerText = "Final Score: " + score;
                uiGameOver.style.display = 'block';
            }
        }, 2000);
    }

    function createExplosion(x, y, color, count = 15) {
        for(let k=0; k<count; k++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0,
                color: color
            });
        }
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.02; 
            if(p.life <= 0) particles.splice(i, 1);
        }
    }

    function updateHUD() {
        elScore.innerText = "SCORE: " + score;
        let hearts = "";
        for(let i=0; i<lives; i++) hearts += "❤";
        elLives.innerText = hearts;
        
        if(combo > 1) {
            elCombo.style.display = 'block';
            elCombo.style.opacity = 1;
            elCombo.innerText = "x" + combo + " COMBO";
        } else {
            elCombo.style.display = 'none';
        }
    }

    function draw() {
        ctx.fillStyle = '#2c3e50';
        ctx.fillRect(0, 0, width, height);

        ctx.fillStyle = '#f1c40f';
        diamonds.forEach(d => {
            ctx.beginPath();
            ctx.moveTo(d.x, d.y - d.radius);
            ctx.lineTo(d.x + d.radius, d.y);
            ctx.lineTo(d.x, d.y + d.radius);
            ctx.lineTo(d.x - d.radius, d.y);
            ctx.fill();
        });

        powerups.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2);
            if(p.type === 'SHIELD') {
                ctx.fillStyle = '#3498db';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = 'white';
                ctx.font = '8px Arial';
                ctx.fillText("S", p.x-2, p.y+3);
            } else {
                ctx.fillStyle = '#f39c12';
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = '8px Arial';
                ctx.fillText("★", p.x-3, p.y+3);
            }
        });

        ctx.fillStyle = '#e74c3c';
        enemies.forEach(e => {
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2);
            ctx.fill();
        });

        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        });

        if (state === 'PLAYING' || state === 'COUNTDOWN') {
            ctx.save();
            ctx.translate(player.x, player.y);
            
            if (shieldActive) {
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0,0, 18, 0, Math.PI*2);
                ctx.stroke();
            }
            if (invincibilityTimer > 0) {
                 if (Math.floor(Date.now() / 50) % 2 === 0) ctx.fillStyle = '#f1c40f';
                 else ctx.fillStyle = '#ecf0f1';
            } else {
                ctx.fillStyle = '#ecf0f1';
            }

            ctx.rotate(player.angle);
            ctx.beginPath();
            ctx.moveTo(player.size, 0);
            ctx.lineTo(-player.size, player.size);
            ctx.lineTo(-player.size * 0.5, 0);
            ctx.lineTo(-player.size, -player.size);
            ctx.fill();
            ctx.restore();
        }

        requestAnimationFrame(draw);
        if(state === 'PLAYING') update();
    }

    draw();
</script>
</body>
</html>
